(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[499],{3499:(n,e,r)=>{Promise.resolve().then(r.t.bind(r,5770,23)),Promise.resolve().then(r.bind(r,2e3)),Promise.resolve().then(r.bind(r,4763))},2e3:(n,e,r)=>{"use strict";r.d(e,{DocsNavigation:()=>a});var t=r(4568),o=r(5770),i=r.n(o);r(3387);let s=JSON.parse('[{"title":"README","category":"general","body":{"raw":"\\n**Modern Vector.js v0.1.0**\\n\\n***\\n\\n# Modern Vector.js v0.1.0\\n\\nModern Vector.js - 벡터 그래픽 라이브러리\\n\\n## Classes\\n\\n- [VectorEngine](classes/VectorEngine.md)\\n\\n## Interfaces\\n\\n- [EventEmitter](interfaces/EventEmitter.md)\\n- [EventService](interfaces/EventService.md)\\n- [Plugin](interfaces/Plugin.md)\\n- [Renderer](interfaces/Renderer.md)\\n- [RendererCapabilities](interfaces/RendererCapabilities.md)\\n- [RendererService](interfaces/RendererService.md)\\n- [Scene](interfaces/Scene.md)\\n- [SceneNode](interfaces/SceneNode.md)\\n- [SceneService](interfaces/SceneService.md)\\n\\n## Type Aliases\\n\\n- [EventHandler](type-aliases/EventHandler.md)\\n","html":"<p><strong>Modern Vector.js v0.1.0</strong></p>\\n<hr>\\n<h1>Modern Vector.js v0.1.0</h1>\\n<p>Modern Vector.js - 벡터 그래픽 라이브러리</p>\\n<h2>Classes</h2>\\n<ul>\\n<li><a href=\\"classes/VectorEngine.md\\">VectorEngine</a></li>\\n</ul>\\n<h2>Interfaces</h2>\\n<ul>\\n<li><a href=\\"interfaces/EventEmitter.md\\">EventEmitter</a></li>\\n<li><a href=\\"interfaces/EventService.md\\">EventService</a></li>\\n<li><a href=\\"interfaces/Plugin.md\\">Plugin</a></li>\\n<li><a href=\\"interfaces/Renderer.md\\">Renderer</a></li>\\n<li><a href=\\"interfaces/RendererCapabilities.md\\">RendererCapabilities</a></li>\\n<li><a href=\\"interfaces/RendererService.md\\">RendererService</a></li>\\n<li><a href=\\"interfaces/Scene.md\\">Scene</a></li>\\n<li><a href=\\"interfaces/SceneNode.md\\">SceneNode</a></li>\\n<li><a href=\\"interfaces/SceneService.md\\">SceneService</a></li>\\n</ul>\\n<h2>Type Aliases</h2>\\n<ul>\\n<li><a href=\\"type-aliases/EventHandler.md\\">EventHandler</a></li>\\n</ul>"},"_id":"api-docs/README.md","_raw":{"sourceFilePath":"api-docs/README.md","sourceFileName":"README.md","sourceFileDir":"api-docs","contentType":"markdown","flattenedPath":"api-docs/README"},"type":"ApiDoc","slug":"README","url":"/api-docs/README"},{"title":"VectorEngine","category":"classes","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / VectorEngine\\n\\n# Class: VectorEngine\\n\\nDefined in: [engine.ts:9](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L9)\\n\\nVector Graphics Engine implementation\\n\\n## Implements\\n\\n- `VectorEngine`\\n\\n## Constructors\\n\\n### new VectorEngine()\\n\\n> **new VectorEngine**(): [`VectorEngine`](VectorEngine.md)\\n\\nDefined in: [engine.ts:16](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L16)\\n\\n#### Returns\\n\\n[`VectorEngine`](VectorEngine.md)\\n\\n## Properties\\n\\n### events\\n\\n> `readonly` **events**: [`EventService`](../interfaces/EventService.md)\\n\\nDefined in: [engine.ts:13](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L13)\\n\\nEvent service\\n\\n#### Implementation of\\n\\n`VectorEngine.events`\\n\\n***\\n\\n### renderer\\n\\n> `readonly` **renderer**: [`RendererService`](../interfaces/RendererService.md)\\n\\nDefined in: [engine.ts:12](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L12)\\n\\nRenderer service\\n\\n#### Implementation of\\n\\n`VectorEngine.renderer`\\n\\n***\\n\\n### scene\\n\\n> `readonly` **scene**: [`SceneService`](../interfaces/SceneService.md)\\n\\nDefined in: [engine.ts:14](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L14)\\n\\nScene service\\n\\n#### Implementation of\\n\\n`VectorEngine.scene`\\n\\n## Methods\\n\\n### getPlugin()\\n\\n> **getPlugin**\\\\<`T`\\\\>(`id`): `null` \\\\| `T`\\n\\nDefined in: [engine.ts:66](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L66)\\n\\nGet a plugin by ID\\n\\n#### Type Parameters\\n\\n• **T** *extends* [`Plugin`](../interfaces/Plugin.md)\\n\\n#### Parameters\\n\\n##### id\\n\\n`string`\\n\\nPlugin ID\\n\\n#### Returns\\n\\n`null` \\\\| `T`\\n\\nThe plugin instance or null if not found\\n\\n#### Implementation of\\n\\n`VectorEngine.getPlugin`\\n\\n***\\n\\n### remove()\\n\\n> **remove**(`pluginId`): `void`\\n\\nDefined in: [engine.ts:46](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L46)\\n\\nRemove a plugin from the engine\\n\\n#### Parameters\\n\\n##### pluginId\\n\\n`string`\\n\\nID of the plugin to remove\\n\\n#### Returns\\n\\n`void`\\n\\n#### Implementation of\\n\\n`VectorEngine.remove`\\n\\n***\\n\\n### use()\\n\\n> **use**(`plugin`): `void`\\n\\nDefined in: [engine.ts:27](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L27)\\n\\nInstall a plugin into the engine\\n\\n#### Parameters\\n\\n##### plugin\\n\\n[`Plugin`](../interfaces/Plugin.md)\\n\\nThe plugin to install\\n\\n#### Returns\\n\\n`void`\\n\\n#### Throws\\n\\nError if plugin dependencies are not met\\n\\n#### Implementation of\\n\\n`VectorEngine.use`\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / VectorEngine</p>\\n<h1>Class: VectorEngine</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L9\\">engine.ts:9</a></p>\\n<p>Vector Graphics Engine implementation</p>\\n<h2>Implements</h2>\\n<ul>\\n<li><code>VectorEngine</code></li>\\n</ul>\\n<h2>Constructors</h2>\\n<h3>new VectorEngine()</h3>\\n<blockquote>\\n<p><strong>new VectorEngine</strong>(): <a href=\\"VectorEngine.md\\"><code>VectorEngine</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L16\\">engine.ts:16</a></p>\\n<h4>Returns</h4>\\n<p><a href=\\"VectorEngine.md\\"><code>VectorEngine</code></a></p>\\n<h2>Properties</h2>\\n<h3>events</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>events</strong>: <a href=\\"../interfaces/EventService.md\\"><code>EventService</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L13\\">engine.ts:13</a></p>\\n<p>Event service</p>\\n<h4>Implementation of</h4>\\n<p><code>VectorEngine.events</code></p>\\n<hr>\\n<h3>renderer</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>renderer</strong>: <a href=\\"../interfaces/RendererService.md\\"><code>RendererService</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L12\\">engine.ts:12</a></p>\\n<p>Renderer service</p>\\n<h4>Implementation of</h4>\\n<p><code>VectorEngine.renderer</code></p>\\n<hr>\\n<h3>scene</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>scene</strong>: <a href=\\"../interfaces/SceneService.md\\"><code>SceneService</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L14\\">engine.ts:14</a></p>\\n<p>Scene service</p>\\n<h4>Implementation of</h4>\\n<p><code>VectorEngine.scene</code></p>\\n<h2>Methods</h2>\\n<h3>getPlugin()</h3>\\n<blockquote>\\n<p><strong>getPlugin</strong>&#x3C;<code>T</code>>(<code>id</code>): <code>null</code> | <code>T</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L66\\">engine.ts:66</a></p>\\n<p>Get a plugin by ID</p>\\n<h4>Type Parameters</h4>\\n<p>• <strong>T</strong> <em>extends</em> <a href=\\"../interfaces/Plugin.md\\"><code>Plugin</code></a></p>\\n<h4>Parameters</h4>\\n<h5>id</h5>\\n<p><code>string</code></p>\\n<p>Plugin ID</p>\\n<h4>Returns</h4>\\n<p><code>null</code> | <code>T</code></p>\\n<p>The plugin instance or null if not found</p>\\n<h4>Implementation of</h4>\\n<p><code>VectorEngine.getPlugin</code></p>\\n<hr>\\n<h3>remove()</h3>\\n<blockquote>\\n<p><strong>remove</strong>(<code>pluginId</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L46\\">engine.ts:46</a></p>\\n<p>Remove a plugin from the engine</p>\\n<h4>Parameters</h4>\\n<h5>pluginId</h5>\\n<p><code>string</code></p>\\n<p>ID of the plugin to remove</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Implementation of</h4>\\n<p><code>VectorEngine.remove</code></p>\\n<hr>\\n<h3>use()</h3>\\n<blockquote>\\n<p><strong>use</strong>(<code>plugin</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/engine.ts#L27\\">engine.ts:27</a></p>\\n<p>Install a plugin into the engine</p>\\n<h4>Parameters</h4>\\n<h5>plugin</h5>\\n<p><a href=\\"../interfaces/Plugin.md\\"><code>Plugin</code></a></p>\\n<p>The plugin to install</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Throws</h4>\\n<p>Error if plugin dependencies are not met</p>\\n<h4>Implementation of</h4>\\n<p><code>VectorEngine.use</code></p>"},"_id":"api-docs/classes/VectorEngine.md","_raw":{"sourceFilePath":"api-docs/classes/VectorEngine.md","sourceFileName":"VectorEngine.md","sourceFileDir":"api-docs/classes","contentType":"markdown","flattenedPath":"api-docs/classes/VectorEngine"},"type":"ApiDoc","slug":"classes/VectorEngine","url":"/api-docs/classes/VectorEngine"},{"title":"EventEmitter","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / EventEmitter\\n\\n# Interface: EventEmitter\\n\\nDefined in: [types/index.ts:94](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L94)\\n\\nEvent emitter interface for handling events\\n\\n이벤트를 발생시키고 처리하기 위한 인터페이스입니다.\\n\\n## Extended by\\n\\n- [`EventService`](EventService.md)\\n- [`Scene`](Scene.md)\\n- [`SceneNode`](SceneNode.md)\\n\\n## Methods\\n\\n### emit()\\n\\n> **emit**(`event`, `data`): `void`\\n\\nDefined in: [types/index.ts:117](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L117)\\n\\n이벤트 발생\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n발생시킬 이벤트 이름\\n\\n##### data\\n\\n`any`\\n\\n이벤트와 함께 전달할 데이터\\n\\n#### Returns\\n\\n`void`\\n\\n***\\n\\n### off()\\n\\n> **off**(`event`, `handler`): `void`\\n\\nDefined in: [types/index.ts:109](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L109)\\n\\n이벤트 리스너 제거\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n이벤트 이름\\n\\n##### handler\\n\\n[`EventHandler`](../type-aliases/EventHandler.md)\\n\\n제거할 이벤트 핸들러 함수\\n\\n#### Returns\\n\\n`void`\\n\\n***\\n\\n### on()\\n\\n> **on**(`event`, `handler`): `void`\\n\\nDefined in: [types/index.ts:101](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L101)\\n\\n이벤트 리스너 등록\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n이벤트 이름\\n\\n##### handler\\n\\n[`EventHandler`](../type-aliases/EventHandler.md)\\n\\n이벤트 핸들러 함수\\n\\n#### Returns\\n\\n`void`\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / EventEmitter</p>\\n<h1>Interface: EventEmitter</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L94\\">types/index.ts:94</a></p>\\n<p>Event emitter interface for handling events</p>\\n<p>이벤트를 발생시키고 처리하기 위한 인터페이스입니다.</p>\\n<h2>Extended by</h2>\\n<ul>\\n<li><a href=\\"EventService.md\\"><code>EventService</code></a></li>\\n<li><a href=\\"Scene.md\\"><code>Scene</code></a></li>\\n<li><a href=\\"SceneNode.md\\"><code>SceneNode</code></a></li>\\n</ul>\\n<h2>Methods</h2>\\n<h3>emit()</h3>\\n<blockquote>\\n<p><strong>emit</strong>(<code>event</code>, <code>data</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L117\\">types/index.ts:117</a></p>\\n<p>이벤트 발생</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>발생시킬 이벤트 이름</p>\\n<h5>data</h5>\\n<p><code>any</code></p>\\n<p>이벤트와 함께 전달할 데이터</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<hr>\\n<h3>off()</h3>\\n<blockquote>\\n<p><strong>off</strong>(<code>event</code>, <code>handler</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L109\\">types/index.ts:109</a></p>\\n<p>이벤트 리스너 제거</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>이벤트 이름</p>\\n<h5>handler</h5>\\n<p><a href=\\"../type-aliases/EventHandler.md\\"><code>EventHandler</code></a></p>\\n<p>제거할 이벤트 핸들러 함수</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<hr>\\n<h3>on()</h3>\\n<blockquote>\\n<p><strong>on</strong>(<code>event</code>, <code>handler</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L101\\">types/index.ts:101</a></p>\\n<p>이벤트 리스너 등록</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>이벤트 이름</p>\\n<h5>handler</h5>\\n<p><a href=\\"../type-aliases/EventHandler.md\\"><code>EventHandler</code></a></p>\\n<p>이벤트 핸들러 함수</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>"},"_id":"api-docs/interfaces/EventEmitter.md","_raw":{"sourceFilePath":"api-docs/interfaces/EventEmitter.md","sourceFileName":"EventEmitter.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/EventEmitter"},"type":"ApiDoc","slug":"interfaces/EventEmitter","url":"/api-docs/interfaces/EventEmitter"},{"title":"EventService","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / EventService\\n\\n# Interface: EventService\\n\\nDefined in: [types/index.ts:153](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L153)\\n\\nService for managing events with namespacing support\\n\\n네임스페이스를 지원하는 이벤트 관리 서비스 인터페이스입니다.\\n\\n## Extends\\n\\n- [`EventEmitter`](EventEmitter.md)\\n\\n## Methods\\n\\n### createNamespace()\\n\\n> **createNamespace**(`name`): [`EventEmitter`](EventEmitter.md)\\n\\nDefined in: [types/index.ts:160](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L160)\\n\\n이벤트 네임스페이스 생성\\n\\n#### Parameters\\n\\n##### name\\n\\n`string`\\n\\n네임스페이스 이름\\n\\n#### Returns\\n\\n[`EventEmitter`](EventEmitter.md)\\n\\n생성된 이벤트 이미터\\n\\n***\\n\\n### emit()\\n\\n> **emit**(`event`, `data`): `void`\\n\\nDefined in: [types/index.ts:117](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L117)\\n\\n이벤트 발생\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n발생시킬 이벤트 이름\\n\\n##### data\\n\\n`any`\\n\\n이벤트와 함께 전달할 데이터\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`emit`](EventEmitter.md#emit)\\n\\n***\\n\\n### off()\\n\\n> **off**(`event`, `handler`): `void`\\n\\nDefined in: [types/index.ts:109](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L109)\\n\\n이벤트 리스너 제거\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n이벤트 이름\\n\\n##### handler\\n\\n[`EventHandler`](../type-aliases/EventHandler.md)\\n\\n제거할 이벤트 핸들러 함수\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`off`](EventEmitter.md#off)\\n\\n***\\n\\n### on()\\n\\n> **on**(`event`, `handler`): `void`\\n\\nDefined in: [types/index.ts:101](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L101)\\n\\n이벤트 리스너 등록\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n이벤트 이름\\n\\n##### handler\\n\\n[`EventHandler`](../type-aliases/EventHandler.md)\\n\\n이벤트 핸들러 함수\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`on`](EventEmitter.md#on)\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / EventService</p>\\n<h1>Interface: EventService</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L153\\">types/index.ts:153</a></p>\\n<p>Service for managing events with namespacing support</p>\\n<p>네임스페이스를 지원하는 이벤트 관리 서비스 인터페이스입니다.</p>\\n<h2>Extends</h2>\\n<ul>\\n<li><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a></li>\\n</ul>\\n<h2>Methods</h2>\\n<h3>createNamespace()</h3>\\n<blockquote>\\n<p><strong>createNamespace</strong>(<code>name</code>): <a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L160\\">types/index.ts:160</a></p>\\n<p>이벤트 네임스페이스 생성</p>\\n<h4>Parameters</h4>\\n<h5>name</h5>\\n<p><code>string</code></p>\\n<p>네임스페이스 이름</p>\\n<h4>Returns</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a></p>\\n<p>생성된 이벤트 이미터</p>\\n<hr>\\n<h3>emit()</h3>\\n<blockquote>\\n<p><strong>emit</strong>(<code>event</code>, <code>data</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L117\\">types/index.ts:117</a></p>\\n<p>이벤트 발생</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>발생시킬 이벤트 이름</p>\\n<h5>data</h5>\\n<p><code>any</code></p>\\n<p>이벤트와 함께 전달할 데이터</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#emit\\"><code>emit</code></a></p>\\n<hr>\\n<h3>off()</h3>\\n<blockquote>\\n<p><strong>off</strong>(<code>event</code>, <code>handler</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L109\\">types/index.ts:109</a></p>\\n<p>이벤트 리스너 제거</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>이벤트 이름</p>\\n<h5>handler</h5>\\n<p><a href=\\"../type-aliases/EventHandler.md\\"><code>EventHandler</code></a></p>\\n<p>제거할 이벤트 핸들러 함수</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#off\\"><code>off</code></a></p>\\n<hr>\\n<h3>on()</h3>\\n<blockquote>\\n<p><strong>on</strong>(<code>event</code>, <code>handler</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L101\\">types/index.ts:101</a></p>\\n<p>이벤트 리스너 등록</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>이벤트 이름</p>\\n<h5>handler</h5>\\n<p><a href=\\"../type-aliases/EventHandler.md\\"><code>EventHandler</code></a></p>\\n<p>이벤트 핸들러 함수</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#on\\"><code>on</code></a></p>"},"_id":"api-docs/interfaces/EventService.md","_raw":{"sourceFilePath":"api-docs/interfaces/EventService.md","sourceFileName":"EventService.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/EventService"},"type":"ApiDoc","slug":"interfaces/EventService","url":"/api-docs/interfaces/EventService"},{"title":"Plugin","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / Plugin\\n\\n# Interface: Plugin\\n\\nDefined in: [types/index.ts:13](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L13)\\n\\nPlugin interface for the vector graphics engine\\n\\n벡터 그래픽 엔진을 위한 플러그인 인터페이스\\n\\n## Properties\\n\\n### dependencies?\\n\\n> `readonly` `optional` **dependencies**: `string`[]\\n\\nDefined in: [types/index.ts:19](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L19)\\n\\nOptional array of plugin IDs that this plugin depends on\\n\\n***\\n\\n### id\\n\\n> `readonly` **id**: `string`\\n\\nDefined in: [types/index.ts:15](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L15)\\n\\nUnique identifier for the plugin\\n\\n***\\n\\n### version\\n\\n> `readonly` **version**: `string`\\n\\nDefined in: [types/index.ts:17](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L17)\\n\\nSemantic version of the plugin\\n\\n## Methods\\n\\n### install()\\n\\n> **install**(`engine`): `void`\\n\\nDefined in: [types/index.ts:28](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L28)\\n\\nInstall the plugin into the engine\\n\\n엔진에 플러그인을 설치합니다.\\n\\n#### Parameters\\n\\n##### engine\\n\\n`VectorEngine`\\n\\nThe vector engine instance\\n\\n#### Returns\\n\\n`void`\\n\\n***\\n\\n### uninstall()\\n\\n> **uninstall**(`engine`): `void`\\n\\nDefined in: [types/index.ts:37](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L37)\\n\\nUninstall the plugin from the engine\\n\\n엔진에서 플러그인을 제거합니다.\\n\\n#### Parameters\\n\\n##### engine\\n\\n`VectorEngine`\\n\\nThe vector engine instance\\n\\n#### Returns\\n\\n`void`\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / Plugin</p>\\n<h1>Interface: Plugin</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L13\\">types/index.ts:13</a></p>\\n<p>Plugin interface for the vector graphics engine</p>\\n<p>벡터 그래픽 엔진을 위한 플러그인 인터페이스</p>\\n<h2>Properties</h2>\\n<h3>dependencies?</h3>\\n<blockquote>\\n<p><code>readonly</code> <code>optional</code> <strong>dependencies</strong>: <code>string</code>[]</p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L19\\">types/index.ts:19</a></p>\\n<p>Optional array of plugin IDs that this plugin depends on</p>\\n<hr>\\n<h3>id</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>id</strong>: <code>string</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L15\\">types/index.ts:15</a></p>\\n<p>Unique identifier for the plugin</p>\\n<hr>\\n<h3>version</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>version</strong>: <code>string</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L17\\">types/index.ts:17</a></p>\\n<p>Semantic version of the plugin</p>\\n<h2>Methods</h2>\\n<h3>install()</h3>\\n<blockquote>\\n<p><strong>install</strong>(<code>engine</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L28\\">types/index.ts:28</a></p>\\n<p>Install the plugin into the engine</p>\\n<p>엔진에 플러그인을 설치합니다.</p>\\n<h4>Parameters</h4>\\n<h5>engine</h5>\\n<p><code>VectorEngine</code></p>\\n<p>The vector engine instance</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<hr>\\n<h3>uninstall()</h3>\\n<blockquote>\\n<p><strong>uninstall</strong>(<code>engine</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L37\\">types/index.ts:37</a></p>\\n<p>Uninstall the plugin from the engine</p>\\n<p>엔진에서 플러그인을 제거합니다.</p>\\n<h4>Parameters</h4>\\n<h5>engine</h5>\\n<p><code>VectorEngine</code></p>\\n<p>The vector engine instance</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>"},"_id":"api-docs/interfaces/Plugin.md","_raw":{"sourceFilePath":"api-docs/interfaces/Plugin.md","sourceFileName":"Plugin.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/Plugin"},"type":"ApiDoc","slug":"interfaces/Plugin","url":"/api-docs/interfaces/Plugin"},{"title":"Renderer","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / Renderer\\n\\n# Interface: Renderer\\n\\nDefined in: [types/index.ts:255](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L255)\\n\\nBase renderer interface\\n\\n다양한 렌더링 백엔드를 위한 기본 인터페이스입니다.\\n\\n## Properties\\n\\n### capabilities\\n\\n> `readonly` **capabilities**: [`RendererCapabilities`](RendererCapabilities.md)\\n\\nDefined in: [types/index.ts:259](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L259)\\n\\nRenderer의 기능\\n\\n***\\n\\n### id\\n\\n> `readonly` **id**: `string`\\n\\nDefined in: [types/index.ts:257](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L257)\\n\\nRenderer의 고유 ID\\n\\n## Methods\\n\\n### dispose()\\n\\n> **dispose**(): `void`\\n\\nDefined in: [types/index.ts:275](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L275)\\n\\n리소스 정리\\n\\nRenderer가 사용한 리소스를 정리합니다.\\n\\n#### Returns\\n\\n`void`\\n\\n***\\n\\n### render()\\n\\n> **render**(`scene`): `void`\\n\\nDefined in: [types/index.ts:268](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L268)\\n\\nScene 렌더링\\n\\n주어진 Scene을 렌더링합니다.\\n\\n#### Parameters\\n\\n##### scene\\n\\n[`Scene`](Scene.md)\\n\\n렌더링할 Scene\\n\\n#### Returns\\n\\n`void`\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / Renderer</p>\\n<h1>Interface: Renderer</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L255\\">types/index.ts:255</a></p>\\n<p>Base renderer interface</p>\\n<p>다양한 렌더링 백엔드를 위한 기본 인터페이스입니다.</p>\\n<h2>Properties</h2>\\n<h3>capabilities</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>capabilities</strong>: <a href=\\"RendererCapabilities.md\\"><code>RendererCapabilities</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L259\\">types/index.ts:259</a></p>\\n<p>Renderer의 기능</p>\\n<hr>\\n<h3>id</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>id</strong>: <code>string</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L257\\">types/index.ts:257</a></p>\\n<p>Renderer의 고유 ID</p>\\n<h2>Methods</h2>\\n<h3>dispose()</h3>\\n<blockquote>\\n<p><strong>dispose</strong>(): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L275\\">types/index.ts:275</a></p>\\n<p>리소스 정리</p>\\n<p>Renderer가 사용한 리소스를 정리합니다.</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<hr>\\n<h3>render()</h3>\\n<blockquote>\\n<p><strong>render</strong>(<code>scene</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L268\\">types/index.ts:268</a></p>\\n<p>Scene 렌더링</p>\\n<p>주어진 Scene을 렌더링합니다.</p>\\n<h4>Parameters</h4>\\n<h5>scene</h5>\\n<p><a href=\\"Scene.md\\"><code>Scene</code></a></p>\\n<p>렌더링할 Scene</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>"},"_id":"api-docs/interfaces/Renderer.md","_raw":{"sourceFilePath":"api-docs/interfaces/Renderer.md","sourceFileName":"Renderer.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/Renderer"},"type":"ApiDoc","slug":"interfaces/Renderer","url":"/api-docs/interfaces/Renderer"},{"title":"RendererCapabilities","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / RendererCapabilities\\n\\n# Interface: RendererCapabilities\\n\\nDefined in: [types/index.ts:283](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L283)\\n\\nRenderer capabilities interface\\n\\n렌더러의 기능과 제한사항을 정의하는 인터페이스입니다.\\n\\n## Properties\\n\\n### maxTextureSize\\n\\n> `readonly` **maxTextureSize**: `number`\\n\\nDefined in: [types/index.ts:285](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L285)\\n\\n최대 텍스처 크기\\n\\n***\\n\\n### supports3D\\n\\n> `readonly` **supports3D**: `boolean`\\n\\nDefined in: [types/index.ts:291](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L291)\\n\\n3D 지원 여부\\n\\n***\\n\\n### supportsSVG\\n\\n> `readonly` **supportsSVG**: `boolean`\\n\\nDefined in: [types/index.ts:287](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L287)\\n\\nSVG 지원 여부\\n\\n***\\n\\n### supportsWebGL\\n\\n> `readonly` **supportsWebGL**: `boolean`\\n\\nDefined in: [types/index.ts:289](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L289)\\n\\nWebGL 지원 여부\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / RendererCapabilities</p>\\n<h1>Interface: RendererCapabilities</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L283\\">types/index.ts:283</a></p>\\n<p>Renderer capabilities interface</p>\\n<p>렌더러의 기능과 제한사항을 정의하는 인터페이스입니다.</p>\\n<h2>Properties</h2>\\n<h3>maxTextureSize</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>maxTextureSize</strong>: <code>number</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L285\\">types/index.ts:285</a></p>\\n<p>최대 텍스처 크기</p>\\n<hr>\\n<h3>supports3D</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>supports3D</strong>: <code>boolean</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L291\\">types/index.ts:291</a></p>\\n<p>3D 지원 여부</p>\\n<hr>\\n<h3>supportsSVG</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>supportsSVG</strong>: <code>boolean</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L287\\">types/index.ts:287</a></p>\\n<p>SVG 지원 여부</p>\\n<hr>\\n<h3>supportsWebGL</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>supportsWebGL</strong>: <code>boolean</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L289\\">types/index.ts:289</a></p>\\n<p>WebGL 지원 여부</p>"},"_id":"api-docs/interfaces/RendererCapabilities.md","_raw":{"sourceFilePath":"api-docs/interfaces/RendererCapabilities.md","sourceFileName":"RendererCapabilities.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/RendererCapabilities"},"type":"ApiDoc","slug":"interfaces/RendererCapabilities","url":"/api-docs/interfaces/RendererCapabilities"},{"title":"RendererService","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / RendererService\\n\\n# Interface: RendererService\\n\\nDefined in: [types/index.ts:125](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L125)\\n\\nService for managing renderers\\n\\n렌더러를 관리하는 서비스 인터페이스입니다.\\n\\n## Methods\\n\\n### register()\\n\\n> **register**(`renderer`): `void`\\n\\nDefined in: [types/index.ts:131](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L131)\\n\\n렌더러 등록\\n\\n#### Parameters\\n\\n##### renderer\\n\\n[`Renderer`](Renderer.md)\\n\\n등록할 렌더러\\n\\n#### Returns\\n\\n`void`\\n\\n***\\n\\n### render()\\n\\n> **render**(`scene`): `void`\\n\\nDefined in: [types/index.ts:145](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L145)\\n\\n장면 렌더링\\n\\n#### Parameters\\n\\n##### scene\\n\\n[`Scene`](Scene.md)\\n\\n렌더링할 장면\\n\\n#### Returns\\n\\n`void`\\n\\n***\\n\\n### setActive()\\n\\n> **setActive**(`rendererId`): `void`\\n\\nDefined in: [types/index.ts:138](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L138)\\n\\n활성 렌더러 설정\\n\\n#### Parameters\\n\\n##### rendererId\\n\\n`string`\\n\\n활성화할 렌더러의 ID\\n\\n#### Returns\\n\\n`void`\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / RendererService</p>\\n<h1>Interface: RendererService</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L125\\">types/index.ts:125</a></p>\\n<p>Service for managing renderers</p>\\n<p>렌더러를 관리하는 서비스 인터페이스입니다.</p>\\n<h2>Methods</h2>\\n<h3>register()</h3>\\n<blockquote>\\n<p><strong>register</strong>(<code>renderer</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L131\\">types/index.ts:131</a></p>\\n<p>렌더러 등록</p>\\n<h4>Parameters</h4>\\n<h5>renderer</h5>\\n<p><a href=\\"Renderer.md\\"><code>Renderer</code></a></p>\\n<p>등록할 렌더러</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<hr>\\n<h3>render()</h3>\\n<blockquote>\\n<p><strong>render</strong>(<code>scene</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L145\\">types/index.ts:145</a></p>\\n<p>장면 렌더링</p>\\n<h4>Parameters</h4>\\n<h5>scene</h5>\\n<p><a href=\\"Scene.md\\"><code>Scene</code></a></p>\\n<p>렌더링할 장면</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<hr>\\n<h3>setActive()</h3>\\n<blockquote>\\n<p><strong>setActive</strong>(<code>rendererId</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L138\\">types/index.ts:138</a></p>\\n<p>활성 렌더러 설정</p>\\n<h4>Parameters</h4>\\n<h5>rendererId</h5>\\n<p><code>string</code></p>\\n<p>활성화할 렌더러의 ID</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>"},"_id":"api-docs/interfaces/RendererService.md","_raw":{"sourceFilePath":"api-docs/interfaces/RendererService.md","sourceFileName":"RendererService.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/RendererService"},"type":"ApiDoc","slug":"interfaces/RendererService","url":"/api-docs/interfaces/RendererService"},{"title":"Scene","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / Scene\\n\\n# Interface: Scene\\n\\nDefined in: [types/index.ts:196](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L196)\\n\\nScene interface representing a container for shapes\\n\\nShape들을 포함하는 장면 인터페이스입니다.\\n\\n## Extends\\n\\n- [`EventEmitter`](EventEmitter.md)\\n\\n## Properties\\n\\n### plugins\\n\\n> `readonly` **plugins**: `Map`\\\\<`string`, [`Plugin`](Plugin.md)\\\\>\\n\\nDefined in: [types/index.ts:202](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L202)\\n\\n장면에 등록된 플러그인 맵\\n\\n***\\n\\n### renderer\\n\\n> `readonly` **renderer**: [`Renderer`](Renderer.md)\\n\\nDefined in: [types/index.ts:200](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L200)\\n\\n장면의 렌더러\\n\\n***\\n\\n### root\\n\\n> `readonly` **root**: [`SceneNode`](SceneNode.md)\\n\\nDefined in: [types/index.ts:198](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L198)\\n\\n장면의 루트 노드\\n\\n## Methods\\n\\n### emit()\\n\\n> **emit**(`event`, `data`): `void`\\n\\nDefined in: [types/index.ts:117](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L117)\\n\\n이벤트 발생\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n발생시킬 이벤트 이름\\n\\n##### data\\n\\n`any`\\n\\n이벤트와 함께 전달할 데이터\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`emit`](EventEmitter.md#emit)\\n\\n***\\n\\n### off()\\n\\n> **off**(`event`, `handler`): `void`\\n\\nDefined in: [types/index.ts:109](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L109)\\n\\n이벤트 리스너 제거\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n이벤트 이름\\n\\n##### handler\\n\\n[`EventHandler`](../type-aliases/EventHandler.md)\\n\\n제거할 이벤트 핸들러 함수\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`off`](EventEmitter.md#off)\\n\\n***\\n\\n### on()\\n\\n> **on**(`event`, `handler`): `void`\\n\\nDefined in: [types/index.ts:101](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L101)\\n\\n이벤트 리스너 등록\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n이벤트 이름\\n\\n##### handler\\n\\n[`EventHandler`](../type-aliases/EventHandler.md)\\n\\n이벤트 핸들러 함수\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`on`](EventEmitter.md#on)\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / Scene</p>\\n<h1>Interface: Scene</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L196\\">types/index.ts:196</a></p>\\n<p>Scene interface representing a container for shapes</p>\\n<p>Shape들을 포함하는 장면 인터페이스입니다.</p>\\n<h2>Extends</h2>\\n<ul>\\n<li><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a></li>\\n</ul>\\n<h2>Properties</h2>\\n<h3>plugins</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>plugins</strong>: <code>Map</code>&#x3C;<code>string</code>, <a href=\\"Plugin.md\\"><code>Plugin</code></a>></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L202\\">types/index.ts:202</a></p>\\n<p>장면에 등록된 플러그인 맵</p>\\n<hr>\\n<h3>renderer</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>renderer</strong>: <a href=\\"Renderer.md\\"><code>Renderer</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L200\\">types/index.ts:200</a></p>\\n<p>장면의 렌더러</p>\\n<hr>\\n<h3>root</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>root</strong>: <a href=\\"SceneNode.md\\"><code>SceneNode</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L198\\">types/index.ts:198</a></p>\\n<p>장면의 루트 노드</p>\\n<h2>Methods</h2>\\n<h3>emit()</h3>\\n<blockquote>\\n<p><strong>emit</strong>(<code>event</code>, <code>data</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L117\\">types/index.ts:117</a></p>\\n<p>이벤트 발생</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>발생시킬 이벤트 이름</p>\\n<h5>data</h5>\\n<p><code>any</code></p>\\n<p>이벤트와 함께 전달할 데이터</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#emit\\"><code>emit</code></a></p>\\n<hr>\\n<h3>off()</h3>\\n<blockquote>\\n<p><strong>off</strong>(<code>event</code>, <code>handler</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L109\\">types/index.ts:109</a></p>\\n<p>이벤트 리스너 제거</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>이벤트 이름</p>\\n<h5>handler</h5>\\n<p><a href=\\"../type-aliases/EventHandler.md\\"><code>EventHandler</code></a></p>\\n<p>제거할 이벤트 핸들러 함수</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#off\\"><code>off</code></a></p>\\n<hr>\\n<h3>on()</h3>\\n<blockquote>\\n<p><strong>on</strong>(<code>event</code>, <code>handler</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L101\\">types/index.ts:101</a></p>\\n<p>이벤트 리스너 등록</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>이벤트 이름</p>\\n<h5>handler</h5>\\n<p><a href=\\"../type-aliases/EventHandler.md\\"><code>EventHandler</code></a></p>\\n<p>이벤트 핸들러 함수</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#on\\"><code>on</code></a></p>"},"_id":"api-docs/interfaces/Scene.md","_raw":{"sourceFilePath":"api-docs/interfaces/Scene.md","sourceFileName":"Scene.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/Scene"},"type":"ApiDoc","slug":"interfaces/Scene","url":"/api-docs/interfaces/Scene"},{"title":"SceneNode","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / SceneNode\\n\\n# Interface: SceneNode\\n\\nDefined in: [types/index.ts:210](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L210)\\n\\nSceneNode interface representing a node in the scene graph\\n\\n장면 그래프의 노드를 나타내는 인터페이스입니다.\\n\\n## Extends\\n\\n- [`EventEmitter`](EventEmitter.md)\\n\\n## Properties\\n\\n### children\\n\\n> `readonly` **children**: [`SceneNode`](SceneNode.md)[]\\n\\nDefined in: [types/index.ts:216](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L216)\\n\\n자식 노드 목록\\n\\n***\\n\\n### data\\n\\n> **data**: `any`\\n\\nDefined in: [types/index.ts:218](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L218)\\n\\n노드에 연결된 데이터\\n\\n***\\n\\n### id\\n\\n> `readonly` **id**: `string`\\n\\nDefined in: [types/index.ts:212](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L212)\\n\\n노드의 고유 ID\\n\\n***\\n\\n### parent\\n\\n> **parent**: `null` \\\\| [`SceneNode`](SceneNode.md)\\n\\nDefined in: [types/index.ts:214](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L214)\\n\\n부모 노드\\n\\n## Methods\\n\\n### addChild()\\n\\n> **addChild**(`child`): [`SceneNode`](SceneNode.md)\\n\\nDefined in: [types/index.ts:226](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L226)\\n\\n자식 노드 추가\\n\\n#### Parameters\\n\\n##### child\\n\\n[`SceneNode`](SceneNode.md)\\n\\n추가할 자식 노드\\n\\n#### Returns\\n\\n[`SceneNode`](SceneNode.md)\\n\\n추가된 자식 노드\\n\\n***\\n\\n### clearChildren()\\n\\n> **clearChildren**(): `void`\\n\\nDefined in: [types/index.ts:239](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L239)\\n\\n모든 자식 노드 제거\\n\\n#### Returns\\n\\n`void`\\n\\n***\\n\\n### emit()\\n\\n> **emit**(`event`, `data`): `void`\\n\\nDefined in: [types/index.ts:117](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L117)\\n\\n이벤트 발생\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n발생시킬 이벤트 이름\\n\\n##### data\\n\\n`any`\\n\\n이벤트와 함께 전달할 데이터\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`emit`](EventEmitter.md#emit)\\n\\n***\\n\\n### findChildById()\\n\\n> **findChildById**(`id`): `null` \\\\| [`SceneNode`](SceneNode.md)\\n\\nDefined in: [types/index.ts:247](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L247)\\n\\nID로 자식 노드 찾기\\n\\n#### Parameters\\n\\n##### id\\n\\n`string`\\n\\n찾을 노드의 ID\\n\\n#### Returns\\n\\n`null` \\\\| [`SceneNode`](SceneNode.md)\\n\\n찾은 노드 또는 null\\n\\n***\\n\\n### off()\\n\\n> **off**(`event`, `handler`): `void`\\n\\nDefined in: [types/index.ts:109](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L109)\\n\\n이벤트 리스너 제거\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n이벤트 이름\\n\\n##### handler\\n\\n[`EventHandler`](../type-aliases/EventHandler.md)\\n\\n제거할 이벤트 핸들러 함수\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`off`](EventEmitter.md#off)\\n\\n***\\n\\n### on()\\n\\n> **on**(`event`, `handler`): `void`\\n\\nDefined in: [types/index.ts:101](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L101)\\n\\n이벤트 리스너 등록\\n\\n#### Parameters\\n\\n##### event\\n\\n`string`\\n\\n이벤트 이름\\n\\n##### handler\\n\\n[`EventHandler`](../type-aliases/EventHandler.md)\\n\\n이벤트 핸들러 함수\\n\\n#### Returns\\n\\n`void`\\n\\n#### Inherited from\\n\\n[`EventEmitter`](EventEmitter.md).[`on`](EventEmitter.md#on)\\n\\n***\\n\\n### removeChild()\\n\\n> **removeChild**(`child`): `boolean`\\n\\nDefined in: [types/index.ts:234](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L234)\\n\\n자식 노드 제거\\n\\n#### Parameters\\n\\n##### child\\n\\n[`SceneNode`](SceneNode.md)\\n\\n제거할 자식 노드\\n\\n#### Returns\\n\\n`boolean`\\n\\n제거 성공 여부\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / SceneNode</p>\\n<h1>Interface: SceneNode</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L210\\">types/index.ts:210</a></p>\\n<p>SceneNode interface representing a node in the scene graph</p>\\n<p>장면 그래프의 노드를 나타내는 인터페이스입니다.</p>\\n<h2>Extends</h2>\\n<ul>\\n<li><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a></li>\\n</ul>\\n<h2>Properties</h2>\\n<h3>children</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>children</strong>: <a href=\\"SceneNode.md\\"><code>SceneNode</code></a>[]</p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L216\\">types/index.ts:216</a></p>\\n<p>자식 노드 목록</p>\\n<hr>\\n<h3>data</h3>\\n<blockquote>\\n<p><strong>data</strong>: <code>any</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L218\\">types/index.ts:218</a></p>\\n<p>노드에 연결된 데이터</p>\\n<hr>\\n<h3>id</h3>\\n<blockquote>\\n<p><code>readonly</code> <strong>id</strong>: <code>string</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L212\\">types/index.ts:212</a></p>\\n<p>노드의 고유 ID</p>\\n<hr>\\n<h3>parent</h3>\\n<blockquote>\\n<p><strong>parent</strong>: <code>null</code> | <a href=\\"SceneNode.md\\"><code>SceneNode</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L214\\">types/index.ts:214</a></p>\\n<p>부모 노드</p>\\n<h2>Methods</h2>\\n<h3>addChild()</h3>\\n<blockquote>\\n<p><strong>addChild</strong>(<code>child</code>): <a href=\\"SceneNode.md\\"><code>SceneNode</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L226\\">types/index.ts:226</a></p>\\n<p>자식 노드 추가</p>\\n<h4>Parameters</h4>\\n<h5>child</h5>\\n<p><a href=\\"SceneNode.md\\"><code>SceneNode</code></a></p>\\n<p>추가할 자식 노드</p>\\n<h4>Returns</h4>\\n<p><a href=\\"SceneNode.md\\"><code>SceneNode</code></a></p>\\n<p>추가된 자식 노드</p>\\n<hr>\\n<h3>clearChildren()</h3>\\n<blockquote>\\n<p><strong>clearChildren</strong>(): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L239\\">types/index.ts:239</a></p>\\n<p>모든 자식 노드 제거</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<hr>\\n<h3>emit()</h3>\\n<blockquote>\\n<p><strong>emit</strong>(<code>event</code>, <code>data</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L117\\">types/index.ts:117</a></p>\\n<p>이벤트 발생</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>발생시킬 이벤트 이름</p>\\n<h5>data</h5>\\n<p><code>any</code></p>\\n<p>이벤트와 함께 전달할 데이터</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#emit\\"><code>emit</code></a></p>\\n<hr>\\n<h3>findChildById()</h3>\\n<blockquote>\\n<p><strong>findChildById</strong>(<code>id</code>): <code>null</code> | <a href=\\"SceneNode.md\\"><code>SceneNode</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L247\\">types/index.ts:247</a></p>\\n<p>ID로 자식 노드 찾기</p>\\n<h4>Parameters</h4>\\n<h5>id</h5>\\n<p><code>string</code></p>\\n<p>찾을 노드의 ID</p>\\n<h4>Returns</h4>\\n<p><code>null</code> | <a href=\\"SceneNode.md\\"><code>SceneNode</code></a></p>\\n<p>찾은 노드 또는 null</p>\\n<hr>\\n<h3>off()</h3>\\n<blockquote>\\n<p><strong>off</strong>(<code>event</code>, <code>handler</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L109\\">types/index.ts:109</a></p>\\n<p>이벤트 리스너 제거</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>이벤트 이름</p>\\n<h5>handler</h5>\\n<p><a href=\\"../type-aliases/EventHandler.md\\"><code>EventHandler</code></a></p>\\n<p>제거할 이벤트 핸들러 함수</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#off\\"><code>off</code></a></p>\\n<hr>\\n<h3>on()</h3>\\n<blockquote>\\n<p><strong>on</strong>(<code>event</code>, <code>handler</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L101\\">types/index.ts:101</a></p>\\n<p>이벤트 리스너 등록</p>\\n<h4>Parameters</h4>\\n<h5>event</h5>\\n<p><code>string</code></p>\\n<p>이벤트 이름</p>\\n<h5>handler</h5>\\n<p><a href=\\"../type-aliases/EventHandler.md\\"><code>EventHandler</code></a></p>\\n<p>이벤트 핸들러 함수</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>\\n<h4>Inherited from</h4>\\n<p><a href=\\"EventEmitter.md\\"><code>EventEmitter</code></a>.<a href=\\"EventEmitter.md#on\\"><code>on</code></a></p>\\n<hr>\\n<h3>removeChild()</h3>\\n<blockquote>\\n<p><strong>removeChild</strong>(<code>child</code>): <code>boolean</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L234\\">types/index.ts:234</a></p>\\n<p>자식 노드 제거</p>\\n<h4>Parameters</h4>\\n<h5>child</h5>\\n<p><a href=\\"SceneNode.md\\"><code>SceneNode</code></a></p>\\n<p>제거할 자식 노드</p>\\n<h4>Returns</h4>\\n<p><code>boolean</code></p>\\n<p>제거 성공 여부</p>"},"_id":"api-docs/interfaces/SceneNode.md","_raw":{"sourceFilePath":"api-docs/interfaces/SceneNode.md","sourceFileName":"SceneNode.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/SceneNode"},"type":"ApiDoc","slug":"interfaces/SceneNode","url":"/api-docs/interfaces/SceneNode"},{"title":"SceneService","category":"interfaces","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / SceneService\\n\\n# Interface: SceneService\\n\\nDefined in: [types/index.ts:168](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L168)\\n\\nService for managing scenes\\n\\n장면을 관리하는 서비스 인터페이스입니다.\\n\\n## Methods\\n\\n### create()\\n\\n> **create**(): [`Scene`](Scene.md)\\n\\nDefined in: [types/index.ts:174](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L174)\\n\\n새 장면 생성\\n\\n#### Returns\\n\\n[`Scene`](Scene.md)\\n\\n생성된 장면\\n\\n***\\n\\n### getActive()\\n\\n> **getActive**(): [`Scene`](Scene.md)\\n\\nDefined in: [types/index.ts:181](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L181)\\n\\n활성 장면 가져오기\\n\\n#### Returns\\n\\n[`Scene`](Scene.md)\\n\\n현재 활성화된 장면\\n\\n***\\n\\n### setActive()\\n\\n> **setActive**(`scene`): `void`\\n\\nDefined in: [types/index.ts:188](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L188)\\n\\n활성 장면 설정\\n\\n#### Parameters\\n\\n##### scene\\n\\n[`Scene`](Scene.md)\\n\\n활성화할 장면\\n\\n#### Returns\\n\\n`void`\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / SceneService</p>\\n<h1>Interface: SceneService</h1>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L168\\">types/index.ts:168</a></p>\\n<p>Service for managing scenes</p>\\n<p>장면을 관리하는 서비스 인터페이스입니다.</p>\\n<h2>Methods</h2>\\n<h3>create()</h3>\\n<blockquote>\\n<p><strong>create</strong>(): <a href=\\"Scene.md\\"><code>Scene</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L174\\">types/index.ts:174</a></p>\\n<p>새 장면 생성</p>\\n<h4>Returns</h4>\\n<p><a href=\\"Scene.md\\"><code>Scene</code></a></p>\\n<p>생성된 장면</p>\\n<hr>\\n<h3>getActive()</h3>\\n<blockquote>\\n<p><strong>getActive</strong>(): <a href=\\"Scene.md\\"><code>Scene</code></a></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L181\\">types/index.ts:181</a></p>\\n<p>활성 장면 가져오기</p>\\n<h4>Returns</h4>\\n<p><a href=\\"Scene.md\\"><code>Scene</code></a></p>\\n<p>현재 활성화된 장면</p>\\n<hr>\\n<h3>setActive()</h3>\\n<blockquote>\\n<p><strong>setActive</strong>(<code>scene</code>): <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L188\\">types/index.ts:188</a></p>\\n<p>활성 장면 설정</p>\\n<h4>Parameters</h4>\\n<h5>scene</h5>\\n<p><a href=\\"Scene.md\\"><code>Scene</code></a></p>\\n<p>활성화할 장면</p>\\n<h4>Returns</h4>\\n<p><code>void</code></p>"},"_id":"api-docs/interfaces/SceneService.md","_raw":{"sourceFilePath":"api-docs/interfaces/SceneService.md","sourceFileName":"SceneService.md","sourceFileDir":"api-docs/interfaces","contentType":"markdown","flattenedPath":"api-docs/interfaces/SceneService"},"type":"ApiDoc","slug":"interfaces/SceneService","url":"/api-docs/interfaces/SceneService"},{"title":"EventHandler","category":"type-aliases","body":{"raw":"\\n[**Modern Vector.js v0.1.0**](../README.md)\\n\\n***\\n\\n[Modern Vector.js](../README.md) / EventHandler\\n\\n# Type Alias: EventHandler()\\n\\n> **EventHandler**: (`data`) => `void`\\n\\nDefined in: [types/index.ts:87](https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L87)\\n\\nEvent handler type definition\\n\\n이벤트 핸들러 함수 타입입니다.\\n\\n## Parameters\\n\\n### data\\n\\n`any`\\n\\n## Returns\\n\\n`void`\\n","html":"<p><a href=\\"../README.md\\"><strong>Modern Vector.js v0.1.0</strong></a></p>\\n<hr>\\n<p><a href=\\"../README.md\\">Modern Vector.js</a> / EventHandler</p>\\n<h1>Type Alias: EventHandler()</h1>\\n<blockquote>\\n<p><strong>EventHandler</strong>: (<code>data</code>) => <code>void</code></p>\\n</blockquote>\\n<p>Defined in: <a href=\\"https://github.com/miridih-jwpark02/modern-vector.js/blob/5221f2fc49f67dd4433b667bc6d0e95a648486aa/packages/core/src/core/types/index.ts#L87\\">types/index.ts:87</a></p>\\n<p>Event handler type definition</p>\\n<p>이벤트 핸들러 함수 타입입니다.</p>\\n<h2>Parameters</h2>\\n<h3>data</h3>\\n<p><code>any</code></p>\\n<h2>Returns</h2>\\n<p><code>void</code></p>"},"_id":"api-docs/type-aliases/EventHandler.md","_raw":{"sourceFilePath":"api-docs/type-aliases/EventHandler.md","sourceFileName":"EventHandler.md","sourceFileDir":"api-docs/type-aliases","contentType":"markdown","flattenedPath":"api-docs/type-aliases/EventHandler"},"type":"ApiDoc","slug":"type-aliases/EventHandler","url":"/api-docs/type-aliases/EventHandler"}]'),c=JSON.parse('[{"title":"API 문서 생성","description":"TypeDoc을 사용하여 Modern Vector.js API 문서를 생성하는 방법","body":{"raw":"\\n# API 문서 생성\\n\\nModern Vector.js는 TypeDoc을 사용하여 TypeScript 코드에서 API 문서를 자동으로 생성합니다. 이 문서에서는 API 문서 생성 방법과 문서 사이트에 통합하는 방법에 대해 설명합니다.\\n\\n## TypeDoc 설정\\n\\n### 설치\\n\\nTypeDoc은 개발 의존성으로 설치되어 있습니다. `package.json` 파일에 다음과 같이 설정되어 있습니다:\\n\\n```json\\n{\\n  \\"devDependencies\\": {\\n    \\"typedoc\\": \\"^0.25.0\\",\\n    \\"typedoc-plugin-markdown\\": \\"^3.17.0\\"\\n  }\\n}\\n```\\n\\n### 설정 파일\\n\\nTypeDoc 설정은 `packages/core/typedoc.json` 파일에 정의되어 있습니다:\\n\\n```json\\n{\\n  \\"entryPoints\\": [\\"./src/index.ts\\"],\\n  \\"out\\": \\"../docs-site/public/api-docs\\",\\n  \\"plugin\\": [\\"typedoc-plugin-markdown\\"],\\n  \\"theme\\": \\"markdown\\",\\n  \\"readme\\": \\"none\\",\\n  \\"excludePrivate\\": true,\\n  \\"excludeProtected\\": true,\\n  \\"excludeInternal\\": true,\\n  \\"excludeExternals\\": true,\\n  \\"githubPages\\": false,\\n  \\"sort\\": [\\"source-order\\"],\\n  \\"categorizeByGroup\\": true,\\n  \\"categoryOrder\\": [\\"Core\\", \\"Services\\", \\"Plugins\\", \\"*\\"]\\n}\\n```\\n\\n주요 설정:\\n- `entryPoints`: 문서화할 진입점 파일\\n- `out`: 생성된 문서의 출력 디렉토리\\n- `plugin`: 사용할 플러그인 (마크다운 형식으로 출력)\\n- `excludePrivate`, `excludeProtected`, `excludeInternal`: 비공개, 보호된, 내부 멤버 제외\\n- `categoryOrder`: 카테고리 정렬 순서\\n\\n## 문서 생성 스크립트\\n\\nAPI 문서 생성을 위한 스크립트는 `packages/docs-site/scripts/generate-docs.js` 파일에 정의되어 있습니다:\\n\\n```javascript\\nconst { execSync } = require(\'child_process\');\\nconst path = require(\'path\');\\nconst fs = require(\'fs\');\\n\\n// 코어 패키지 경로\\nconst corePath = path.resolve(__dirname, \'../../core\');\\n\\n// TypeDoc 실행\\nconsole.log(\'Generating API documentation...\');\\ntry {\\n  execSync(\'pnpm typedoc\', { cwd: corePath, stdio: \'inherit\' });\\n  console.log(\'API documentation generated successfully!\');\\n} catch (error) {\\n  console.error(\'Error generating API documentation:\', error);\\n  process.exit(1);\\n}\\n```\\n\\n이 스크립트는 core 패키지 디렉토리에서 `pnpm typedoc` 명령을 실행하여 API 문서를 생성합니다.\\n\\n## 문서 생성 명령\\n\\nAPI 문서를 생성하려면 다음 명령을 실행합니다:\\n\\n```bash\\n# docs-site 디렉토리에서\\npnpm run generate-docs\\n```\\n\\n이 명령은 `package.json` 파일에 다음과 같이 정의되어 있습니다:\\n\\n```json\\n{\\n  \\"scripts\\": {\\n    \\"generate-docs\\": \\"node scripts/generate-docs.js\\"\\n  }\\n}\\n```\\n\\n## TSDoc 주석 작성 가이드\\n\\nTypeDoc은 TSDoc 형식의 주석을 사용하여 API 문서를 생성합니다. 다음은 TSDoc 주석 작성 가이드입니다:\\n\\n### 클래스 문서화\\n\\n```typescript\\n/**\\n * Vector Engine 구현 클래스\\n * \\n * 플러그인 기반 벡터 그래픽 시스템의 핵심 엔진입니다.\\n * \\n * @example\\n * ```typescript\\n * const engine = new VectorEngine();\\n * engine.use(new CanvasRenderer());\\n * ```\\n */\\nexport class VectorEngineImpl implements VectorEngine {\\n  // ...\\n}\\n```\\n\\n### 메서드 문서화\\n\\n```typescript\\n/**\\n * 플러그인을 엔진에 등록합니다.\\n * \\n * @param plugin - 등록할 Plugin 인스턴스\\n * @throws {Error} 이미 동일한 ID의 플러그인이 등록된 경우\\n * @returns 등록된 플러그인 인스턴스\\n */\\npublic use(plugin: Plugin): Plugin {\\n  // ...\\n}\\n```\\n\\n### 인터페이스 문서화\\n\\n```typescript\\n/**\\n * 벡터 엔진의 플러그인 인터페이스\\n * \\n * 모든 플러그인은 이 인터페이스를 구현해야 합니다.\\n */\\nexport interface Plugin {\\n  /**\\n   * 플러그인의 고유 식별자\\n   */\\n  readonly id: string;\\n  \\n  /**\\n   * 플러그인의 버전\\n   */\\n  readonly version: string;\\n  \\n  /**\\n   * 플러그인의 의존성 목록\\n   */\\n  readonly dependencies?: string[];\\n  \\n  /**\\n   * 플러그인을 엔진에 설치합니다.\\n   * \\n   * @param engine - 벡터 엔진 인스턴스\\n   */\\n  install(engine: VectorEngine): void;\\n  \\n  /**\\n   * 플러그인을 엔진에서 제거합니다.\\n   * \\n   * @param engine - 벡터 엔진 인스턴스\\n   */\\n  uninstall(engine: VectorEngine): void;\\n}\\n```\\n\\n### 타입 문서화\\n\\n```typescript\\n/**\\n * 이벤트 핸들러 함수 타입\\n * \\n * @typeParam T - 이벤트 데이터 타입\\n * @param data - 이벤트 데이터\\n */\\nexport type EventHandler<T = any> = (data: T) => void;\\n```\\n\\n## 문서 사이트 통합\\n\\n생성된 API 문서는 `packages/docs-site/public/api-docs` 디렉토리에 저장됩니다. 이 문서는 Next.js 애플리케이션에서 다음과 같이 통합됩니다:\\n\\n### API 문서 페이지\\n\\n`src/app/api/page.tsx` 파일에서 API 문서 목록을 표시합니다:\\n\\n```tsx\\nimport { getApiDocsList } from \'@/lib/api-docs\';\\n\\nexport default function ApiDocsPage() {\\n  const apiDocs = getApiDocsList();\\n  \\n  return (\\n    <div>\\n      <h1>API 문서</h1>\\n      <ul>\\n        {apiDocs.map((doc) => (\\n          <li key={doc.path}>\\n            <a href={`/api/${doc.path}`}>{doc.title}</a>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n}\\n```\\n\\n### API 문서 유틸리티\\n\\n`src/lib/api-docs.ts` 파일에서 API 문서 목록을 가져오는 함수를 정의합니다:\\n\\n```typescript\\nimport fs from \'fs\';\\nimport path from \'path\';\\n\\nexport function getApiDocsList() {\\n  const apiDocsDir = path.join(process.cwd(), \'public/api-docs\');\\n  const files = fs.readdirSync(apiDocsDir);\\n  \\n  return files\\n    .filter(file => file.endsWith(\'.md\'))\\n    .map(file => {\\n      const content = fs.readFileSync(path.join(apiDocsDir, file), \'utf-8\');\\n      const titleMatch = content.match(/^# (.+)$/m);\\n      const title = titleMatch ? titleMatch[1] : file.replace(\'.md\', \'\');\\n      \\n      return {\\n        path: file.replace(\'.md\', \'\'),\\n        title\\n      };\\n    });\\n}\\n```\\n\\n## 빌드 프로세스 통합\\n\\nAPI 문서 생성은 빌드 프로세스에 통합되어 있습니다. `package.json` 파일에 다음과 같이 정의되어 있습니다:\\n\\n```json\\n{\\n  \\"scripts\\": {\\n    \\"build\\": \\"pnpm run generate-docs && next build\\"\\n  }\\n}\\n```\\n\\n이렇게 하면 `pnpm run build` 명령을 실행할 때 API 문서가 자동으로 생성됩니다.\\n\\n## 문제 해결\\n\\n### 문서 생성 실패\\n\\nAPI 문서 생성이 실패하는 경우:\\n\\n1. TypeScript 코드에 오류가 없는지 확인\\n2. TypeDoc 버전이 호환되는지 확인\\n3. `typedoc.json` 설정이 올바른지 확인\\n\\n### 문서 내용 누락\\n\\n일부 API 문서 내용이 누락된 경우:\\n\\n1. TSDoc 주석이 올바르게 작성되었는지 확인\\n2. `typedoc.json` 설정에서 `excludePrivate`, `excludeProtected` 등의 설정 확인\\n3. 문서화하려는 항목이 `index.ts`에서 내보내졌는지 확인\\n\\n### 스타일 문제\\n\\n생성된 마크다운 문서의 스타일에 문제가 있는 경우:\\n\\n1. `typedoc-plugin-markdown` 플러그인 버전 확인\\n2. 마크다운 렌더링 컴포넌트 확인 ","html":"<h1>API 문서 생성</h1>\\n<p>Modern Vector.js는 TypeDoc을 사용하여 TypeScript 코드에서 API 문서를 자동으로 생성합니다. 이 문서에서는 API 문서 생성 방법과 문서 사이트에 통합하는 방법에 대해 설명합니다.</p>\\n<h2>TypeDoc 설정</h2>\\n<h3>설치</h3>\\n<p>TypeDoc은 개발 의존성으로 설치되어 있습니다. <code>package.json</code> 파일에 다음과 같이 설정되어 있습니다:</p>\\n<pre><code class=\\"language-json\\">{\\n  \\"devDependencies\\": {\\n    \\"typedoc\\": \\"^0.25.0\\",\\n    \\"typedoc-plugin-markdown\\": \\"^3.17.0\\"\\n  }\\n}\\n</code></pre>\\n<h3>설정 파일</h3>\\n<p>TypeDoc 설정은 <code>packages/core/typedoc.json</code> 파일에 정의되어 있습니다:</p>\\n<pre><code class=\\"language-json\\">{\\n  \\"entryPoints\\": [\\"./src/index.ts\\"],\\n  \\"out\\": \\"../docs-site/public/api-docs\\",\\n  \\"plugin\\": [\\"typedoc-plugin-markdown\\"],\\n  \\"theme\\": \\"markdown\\",\\n  \\"readme\\": \\"none\\",\\n  \\"excludePrivate\\": true,\\n  \\"excludeProtected\\": true,\\n  \\"excludeInternal\\": true,\\n  \\"excludeExternals\\": true,\\n  \\"githubPages\\": false,\\n  \\"sort\\": [\\"source-order\\"],\\n  \\"categorizeByGroup\\": true,\\n  \\"categoryOrder\\": [\\"Core\\", \\"Services\\", \\"Plugins\\", \\"*\\"]\\n}\\n</code></pre>\\n<p>주요 설정:</p>\\n<ul>\\n<li><code>entryPoints</code>: 문서화할 진입점 파일</li>\\n<li><code>out</code>: 생성된 문서의 출력 디렉토리</li>\\n<li><code>plugin</code>: 사용할 플러그인 (마크다운 형식으로 출력)</li>\\n<li><code>excludePrivate</code>, <code>excludeProtected</code>, <code>excludeInternal</code>: 비공개, 보호된, 내부 멤버 제외</li>\\n<li><code>categoryOrder</code>: 카테고리 정렬 순서</li>\\n</ul>\\n<h2>문서 생성 스크립트</h2>\\n<p>API 문서 생성을 위한 스크립트는 <code>packages/docs-site/scripts/generate-docs.js</code> 파일에 정의되어 있습니다:</p>\\n<pre><code class=\\"language-javascript\\">const { execSync } = require(\'child_process\');\\nconst path = require(\'path\');\\nconst fs = require(\'fs\');\\n\\n// 코어 패키지 경로\\nconst corePath = path.resolve(__dirname, \'../../core\');\\n\\n// TypeDoc 실행\\nconsole.log(\'Generating API documentation...\');\\ntry {\\n  execSync(\'pnpm typedoc\', { cwd: corePath, stdio: \'inherit\' });\\n  console.log(\'API documentation generated successfully!\');\\n} catch (error) {\\n  console.error(\'Error generating API documentation:\', error);\\n  process.exit(1);\\n}\\n</code></pre>\\n<p>이 스크립트는 core 패키지 디렉토리에서 <code>pnpm typedoc</code> 명령을 실행하여 API 문서를 생성합니다.</p>\\n<h2>문서 생성 명령</h2>\\n<p>API 문서를 생성하려면 다음 명령을 실행합니다:</p>\\n<pre><code class=\\"language-bash\\"># docs-site 디렉토리에서\\npnpm run generate-docs\\n</code></pre>\\n<p>이 명령은 <code>package.json</code> 파일에 다음과 같이 정의되어 있습니다:</p>\\n<pre><code class=\\"language-json\\">{\\n  \\"scripts\\": {\\n    \\"generate-docs\\": \\"node scripts/generate-docs.js\\"\\n  }\\n}\\n</code></pre>\\n<h2>TSDoc 주석 작성 가이드</h2>\\n<p>TypeDoc은 TSDoc 형식의 주석을 사용하여 API 문서를 생성합니다. 다음은 TSDoc 주석 작성 가이드입니다:</p>\\n<h3>클래스 문서화</h3>\\n<pre><code class=\\"language-typescript\\">/**\\n * Vector Engine 구현 클래스\\n * \\n * 플러그인 기반 벡터 그래픽 시스템의 핵심 엔진입니다.\\n * \\n * @example\\n * ```typescript\\n * const engine = new VectorEngine();\\n * engine.use(new CanvasRenderer());\\n * ```\\n */\\nexport class VectorEngineImpl implements VectorEngine {\\n  // ...\\n}\\n</code></pre>\\n<h3>메서드 문서화</h3>\\n<pre><code class=\\"language-typescript\\">/**\\n * 플러그인을 엔진에 등록합니다.\\n * \\n * @param plugin - 등록할 Plugin 인스턴스\\n * @throws {Error} 이미 동일한 ID의 플러그인이 등록된 경우\\n * @returns 등록된 플러그인 인스턴스\\n */\\npublic use(plugin: Plugin): Plugin {\\n  // ...\\n}\\n</code></pre>\\n<h3>인터페이스 문서화</h3>\\n<pre><code class=\\"language-typescript\\">/**\\n * 벡터 엔진의 플러그인 인터페이스\\n * \\n * 모든 플러그인은 이 인터페이스를 구현해야 합니다.\\n */\\nexport interface Plugin {\\n  /**\\n   * 플러그인의 고유 식별자\\n   */\\n  readonly id: string;\\n  \\n  /**\\n   * 플러그인의 버전\\n   */\\n  readonly version: string;\\n  \\n  /**\\n   * 플러그인의 의존성 목록\\n   */\\n  readonly dependencies?: string[];\\n  \\n  /**\\n   * 플러그인을 엔진에 설치합니다.\\n   * \\n   * @param engine - 벡터 엔진 인스턴스\\n   */\\n  install(engine: VectorEngine): void;\\n  \\n  /**\\n   * 플러그인을 엔진에서 제거합니다.\\n   * \\n   * @param engine - 벡터 엔진 인스턴스\\n   */\\n  uninstall(engine: VectorEngine): void;\\n}\\n</code></pre>\\n<h3>타입 문서화</h3>\\n<pre><code class=\\"language-typescript\\">/**\\n * 이벤트 핸들러 함수 타입\\n * \\n * @typeParam T - 이벤트 데이터 타입\\n * @param data - 이벤트 데이터\\n */\\nexport type EventHandler&#x3C;T = any> = (data: T) => void;\\n</code></pre>\\n<h2>문서 사이트 통합</h2>\\n<p>생성된 API 문서는 <code>packages/docs-site/public/api-docs</code> 디렉토리에 저장됩니다. 이 문서는 Next.js 애플리케이션에서 다음과 같이 통합됩니다:</p>\\n<h3>API 문서 페이지</h3>\\n<p><code>src/app/api/page.tsx</code> 파일에서 API 문서 목록을 표시합니다:</p>\\n<pre><code class=\\"language-tsx\\">import { getApiDocsList } from \'@/lib/api-docs\';\\n\\nexport default function ApiDocsPage() {\\n  const apiDocs = getApiDocsList();\\n  \\n  return (\\n    &#x3C;div>\\n      &#x3C;h1>API 문서&#x3C;/h1>\\n      &#x3C;ul>\\n        {apiDocs.map((doc) => (\\n          &#x3C;li key={doc.path}>\\n            &#x3C;a href={`/api/${doc.path}`}>{doc.title}&#x3C;/a>\\n          &#x3C;/li>\\n        ))}\\n      &#x3C;/ul>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<h3>API 문서 유틸리티</h3>\\n<p><code>src/lib/api-docs.ts</code> 파일에서 API 문서 목록을 가져오는 함수를 정의합니다:</p>\\n<pre><code class=\\"language-typescript\\">import fs from \'fs\';\\nimport path from \'path\';\\n\\nexport function getApiDocsList() {\\n  const apiDocsDir = path.join(process.cwd(), \'public/api-docs\');\\n  const files = fs.readdirSync(apiDocsDir);\\n  \\n  return files\\n    .filter(file => file.endsWith(\'.md\'))\\n    .map(file => {\\n      const content = fs.readFileSync(path.join(apiDocsDir, file), \'utf-8\');\\n      const titleMatch = content.match(/^# (.+)$/m);\\n      const title = titleMatch ? titleMatch[1] : file.replace(\'.md\', \'\');\\n      \\n      return {\\n        path: file.replace(\'.md\', \'\'),\\n        title\\n      };\\n    });\\n}\\n</code></pre>\\n<h2>빌드 프로세스 통합</h2>\\n<p>API 문서 생성은 빌드 프로세스에 통합되어 있습니다. <code>package.json</code> 파일에 다음과 같이 정의되어 있습니다:</p>\\n<pre><code class=\\"language-json\\">{\\n  \\"scripts\\": {\\n    \\"build\\": \\"pnpm run generate-docs &#x26;&#x26; next build\\"\\n  }\\n}\\n</code></pre>\\n<p>이렇게 하면 <code>pnpm run build</code> 명령을 실행할 때 API 문서가 자동으로 생성됩니다.</p>\\n<h2>문제 해결</h2>\\n<h3>문서 생성 실패</h3>\\n<p>API 문서 생성이 실패하는 경우:</p>\\n<ol>\\n<li>TypeScript 코드에 오류가 없는지 확인</li>\\n<li>TypeDoc 버전이 호환되는지 확인</li>\\n<li><code>typedoc.json</code> 설정이 올바른지 확인</li>\\n</ol>\\n<h3>문서 내용 누락</h3>\\n<p>일부 API 문서 내용이 누락된 경우:</p>\\n<ol>\\n<li>TSDoc 주석이 올바르게 작성되었는지 확인</li>\\n<li><code>typedoc.json</code> 설정에서 <code>excludePrivate</code>, <code>excludeProtected</code> 등의 설정 확인</li>\\n<li>문서화하려는 항목이 <code>index.ts</code>에서 내보내졌는지 확인</li>\\n</ol>\\n<h3>스타일 문제</h3>\\n<p>생성된 마크다운 문서의 스타일에 문제가 있는 경우:</p>\\n<ol>\\n<li><code>typedoc-plugin-markdown</code> 플러그인 버전 확인</li>\\n<li>마크다운 렌더링 컴포넌트 확인</li>\\n</ol>"},"_id":"docs/api-docs/generation.md","_raw":{"sourceFilePath":"docs/api-docs/generation.md","sourceFileName":"generation.md","sourceFileDir":"docs/api-docs","contentType":"markdown","flattenedPath":"docs/api-docs/generation"},"type":"Doc","slug":"api-docs/generation","url":"/docs/api-docs/generation"},{"title":"API 레퍼런스","description":"Modern Vector.js API 레퍼런스 문서","body":{"raw":"\\n# API 레퍼런스\\n\\nModern Vector.js는 벡터 그래픽을 쉽게 생성하고 조작할 수 있는 다양한 API를 제공합니다. 이 섹션에서는 라이브러리의 주요 클래스, 인터페이스, 타입 및 함수에 대한 상세한 문서를 찾을 수 있습니다.\\n\\n## 주요 API 카테고리\\n\\n### Core\\n\\n- [VectorEngine](/docs/api-reference/core/vector-engine) - 라이브러리의 핵심 엔진 클래스\\n- [Plugin](/docs/api-reference/core/plugin) - 플러그인 인터페이스 및 관련 타입\\n- [Service](/docs/api-reference/core/service) - 서비스 시스템 관련 API\\n\\n### Renderers\\n\\n- [CanvasRenderer](/docs/api-reference/renderers/canvas-renderer) - Canvas API를 사용한 렌더링\\n- [SVGRenderer](/docs/api-reference/renderers/svg-renderer) - SVG 기반 렌더링\\n- [WebGLRenderer](/docs/api-reference/renderers/webgl-renderer) - WebGL을 사용한 고성능 렌더링\\n\\n### Math\\n\\n- [Vector](/docs/api-reference/math/vector) - 벡터 연산 관련 클래스 및 함수\\n- [Matrix](/docs/api-reference/math/matrix) - 행렬 연산 관련 클래스 및 함수\\n- [Transform](/docs/api-reference/math/transform) - 변환 관련 유틸리티\\n\\n### Shapes\\n\\n- [Shape](/docs/api-reference/shapes/shape) - 기본 도형 인터페이스\\n- [Path](/docs/api-reference/shapes/path) - 경로 관련 클래스 및 함수\\n- [Primitives](/docs/api-reference/shapes/primitives) - 기본 도형 (사각형, 원, 다각형 등)\\n\\n### Effects\\n\\n- [Filter](/docs/api-reference/effects/filter) - 필터 효과 관련 API\\n- [Animation](/docs/api-reference/effects/animation) - 애니메이션 관련 클래스 및 함수\\n\\n### Tools\\n\\n- [SelectionTool](/docs/api-reference/tools/selection-tool) - 선택 도구 관련 API\\n- [TransformTool](/docs/api-reference/tools/transform-tool) - 변환 도구 관련 API\\n\\n## API 문서 사용 방법\\n\\n각 API 문서 페이지는 다음 정보를 포함합니다:\\n\\n- **설명**: API의 목적과 기능에 대한 개요\\n- **구문**: 클래스, 인터페이스, 함수 등의 선언 구문\\n- **매개변수**: 함수나 생성자에 전달되는 매개변수 설명\\n- **반환 값**: 함수나 메서드가 반환하는 값의 타입과 설명\\n- **예제**: API 사용 방법을 보여주는 코드 예제\\n- **관련 API**: 연관된 다른 API에 대한 링크\\n\\n자세한 API 문서는 [TypeDoc으로 생성된 API 문서](/api-docs)에서도 확인할 수 있습니다. ","html":"<h1>API 레퍼런스</h1>\\n<p>Modern Vector.js는 벡터 그래픽을 쉽게 생성하고 조작할 수 있는 다양한 API를 제공합니다. 이 섹션에서는 라이브러리의 주요 클래스, 인터페이스, 타입 및 함수에 대한 상세한 문서를 찾을 수 있습니다.</p>\\n<h2>주요 API 카테고리</h2>\\n<h3>Core</h3>\\n<ul>\\n<li><a href=\\"/docs/api-reference/core/vector-engine\\">VectorEngine</a> - 라이브러리의 핵심 엔진 클래스</li>\\n<li><a href=\\"/docs/api-reference/core/plugin\\">Plugin</a> - 플러그인 인터페이스 및 관련 타입</li>\\n<li><a href=\\"/docs/api-reference/core/service\\">Service</a> - 서비스 시스템 관련 API</li>\\n</ul>\\n<h3>Renderers</h3>\\n<ul>\\n<li><a href=\\"/docs/api-reference/renderers/canvas-renderer\\">CanvasRenderer</a> - Canvas API를 사용한 렌더링</li>\\n<li><a href=\\"/docs/api-reference/renderers/svg-renderer\\">SVGRenderer</a> - SVG 기반 렌더링</li>\\n<li><a href=\\"/docs/api-reference/renderers/webgl-renderer\\">WebGLRenderer</a> - WebGL을 사용한 고성능 렌더링</li>\\n</ul>\\n<h3>Math</h3>\\n<ul>\\n<li><a href=\\"/docs/api-reference/math/vector\\">Vector</a> - 벡터 연산 관련 클래스 및 함수</li>\\n<li><a href=\\"/docs/api-reference/math/matrix\\">Matrix</a> - 행렬 연산 관련 클래스 및 함수</li>\\n<li><a href=\\"/docs/api-reference/math/transform\\">Transform</a> - 변환 관련 유틸리티</li>\\n</ul>\\n<h3>Shapes</h3>\\n<ul>\\n<li><a href=\\"/docs/api-reference/shapes/shape\\">Shape</a> - 기본 도형 인터페이스</li>\\n<li><a href=\\"/docs/api-reference/shapes/path\\">Path</a> - 경로 관련 클래스 및 함수</li>\\n<li><a href=\\"/docs/api-reference/shapes/primitives\\">Primitives</a> - 기본 도형 (사각형, 원, 다각형 등)</li>\\n</ul>\\n<h3>Effects</h3>\\n<ul>\\n<li><a href=\\"/docs/api-reference/effects/filter\\">Filter</a> - 필터 효과 관련 API</li>\\n<li><a href=\\"/docs/api-reference/effects/animation\\">Animation</a> - 애니메이션 관련 클래스 및 함수</li>\\n</ul>\\n<h3>Tools</h3>\\n<ul>\\n<li><a href=\\"/docs/api-reference/tools/selection-tool\\">SelectionTool</a> - 선택 도구 관련 API</li>\\n<li><a href=\\"/docs/api-reference/tools/transform-tool\\">TransformTool</a> - 변환 도구 관련 API</li>\\n</ul>\\n<h2>API 문서 사용 방법</h2>\\n<p>각 API 문서 페이지는 다음 정보를 포함합니다:</p>\\n<ul>\\n<li><strong>설명</strong>: API의 목적과 기능에 대한 개요</li>\\n<li><strong>구문</strong>: 클래스, 인터페이스, 함수 등의 선언 구문</li>\\n<li><strong>매개변수</strong>: 함수나 생성자에 전달되는 매개변수 설명</li>\\n<li><strong>반환 값</strong>: 함수나 메서드가 반환하는 값의 타입과 설명</li>\\n<li><strong>예제</strong>: API 사용 방법을 보여주는 코드 예제</li>\\n<li><strong>관련 API</strong>: 연관된 다른 API에 대한 링크</li>\\n</ul>\\n<p>자세한 API 문서는 <a href=\\"/api-docs\\">TypeDoc으로 생성된 API 문서</a>에서도 확인할 수 있습니다.</p>"},"_id":"docs/api-reference/index.md","_raw":{"sourceFilePath":"docs/api-reference/index.md","sourceFileName":"index.md","sourceFileDir":"docs/api-reference","contentType":"markdown","flattenedPath":"docs/api-reference"},"type":"Doc","slug":"api-reference","url":"/docs/api-reference"},{"title":"플러그인 시스템","description":"Modern Vector.js의 플러그인 시스템 아키텍처와 사용법","body":{"raw":"\\n# 플러그인 시스템\\n\\nModern Vector.js는 플러그인 기반 아키텍처를 채택하여 확장성과 유연성을 제공합니다. 이 문서에서는 플러그인 시스템의 구조, 작동 방식, 그리고 사용자 정의 플러그인 개발 방법에 대해 설명합니다.\\n\\n## 플러그인 아키텍처\\n\\nModern Vector.js의 플러그인 아키텍처는 다음과 같은 구성 요소로 이루어져 있습니다:\\n\\n1. **Core Engine**: 최소한의 기능을 제공하는 핵심 엔진\\n2. **Plugin Interface**: 모든 플러그인이 구현해야 하는 인터페이스\\n3. **Plugin Registry**: 플러그인을 등록하고 관리하는 레지스트리\\n4. **Service System**: 플러그인 간 통신을 위한 서비스 시스템\\n\\n### Plugin 인터페이스\\n\\n모든 플러그인은 `Plugin` 인터페이스를 구현해야 합니다:\\n\\n```typescript\\ninterface Plugin {\\n  /**\\n   * 플러그인의 고유 식별자\\n   */\\n  readonly id: string;\\n  \\n  /**\\n   * 플러그인의 버전\\n   */\\n  readonly version: string;\\n  \\n  /**\\n   * 플러그인의 의존성 목록\\n   */\\n  readonly dependencies?: string[];\\n  \\n  /**\\n   * 플러그인을 엔진에 설치합니다.\\n   * \\n   * @param engine - 벡터 엔진 인스턴스\\n   */\\n  install(engine: VectorEngine): void;\\n  \\n  /**\\n   * 플러그인을 엔진에서 제거합니다.\\n   * \\n   * @param engine - 벡터 엔진 인스턴스\\n   */\\n  uninstall(engine: VectorEngine): void;\\n}\\n```\\n\\n## 플러그인 카테고리\\n\\nModern Vector.js의 플러그인은 다음과 같은 카테고리로 나뉩니다:\\n\\n### 1. Core Plugins (기본 제공)\\n\\n코어 플러그인은 기본적인 벡터 그래픽 기능을 제공합니다:\\n\\n- **MathPlugin**: 벡터, 행렬, 기하학 연산 제공\\n- **ShapePlugin**: 기본 도형 생성 및 관리\\n- **TransformPlugin**: 변환(이동, 회전, 크기 조절 등) 기능 제공\\n\\n### 2. Renderer Plugins\\n\\n렌더러 플러그인은 다양한 렌더링 백엔드를 지원합니다:\\n\\n- **CanvasRendererPlugin**: HTML Canvas 렌더링\\n- **SVGRendererPlugin**: SVG 렌더링\\n- **WebGLRendererPlugin**: WebGL 렌더링\\n\\n### 3. Effect Plugins\\n\\n효과 플러그인은 시각적 효과를 제공합니다:\\n\\n- **FilterPlugin**: 필터 효과 (블러, 그림자 등)\\n- **AnimationPlugin**: 애니메이션 효과\\n\\n### 4. Tool Plugins\\n\\n도구 플러그인은 사용자 상호작용 기능을 제공합니다:\\n\\n- **SelectionToolPlugin**: 객체 선택 도구\\n- **TransformToolPlugin**: 객체 변환 도구\\n\\n## 플러그인 사용하기\\n\\n### 플러그인 등록\\n\\n플러그인을 사용하려면 `VectorEngine`의 `use` 메서드를 사용하여 등록합니다:\\n\\n```typescript\\nimport { VectorEngine } from \'@modern-vector/core\';\\nimport { CanvasRenderer, ShapePlugin, MathPlugin } from \'@modern-vector/plugins\';\\n\\n// 엔진 초기화\\nconst engine = new VectorEngine();\\n\\n// 플러그인 등록\\nengine.use(new MathPlugin());\\nengine.use(new CanvasRenderer());\\nengine.use(new ShapePlugin());\\n```\\n\\n### 플러그인 접근\\n\\n등록된 플러그인은 `getPlugin` 메서드를 사용하여 접근할 수 있습니다:\\n\\n```typescript\\n// 플러그인 접근\\nconst shapePlugin = engine.getPlugin<ShapePlugin>(\'shape\');\\nconst mathPlugin = engine.getPlugin<MathPlugin>(\'math\');\\n\\n// 플러그인 사용\\nconst rect = shapePlugin.createRect({\\n  x: 100,\\n  y: 100,\\n  width: 200,\\n  height: 150\\n});\\n\\nconst vector = mathPlugin.vector.create(10, 20);\\n```\\n\\n### 플러그인 제거\\n\\n플러그인을 제거하려면 `remove` 메서드를 사용합니다:\\n\\n```typescript\\n// 플러그인 제거\\nengine.remove(\'shape\');\\n```\\n\\n## 플러그인 개발하기\\n\\n### 기본 플러그인 구현\\n\\n사용자 정의 플러그인을 개발하려면 `Plugin` 인터페이스를 구현하는 클래스를 작성합니다:\\n\\n```typescript\\nimport { Plugin, VectorEngine } from \'@modern-vector/core\';\\n\\nexport class MyCustomPlugin implements Plugin {\\n  readonly id = \'my-custom-plugin\';\\n  readonly version = \'1.0.0\';\\n  readonly dependencies = [\'math\', \'shape\'];\\n  \\n  install(engine: VectorEngine): void {\\n    // 플러그인 초기화 코드\\n    console.log(\'MyCustomPlugin installed\');\\n    \\n    // 의존성 플러그인 접근\\n    const mathPlugin = engine.getPlugin(\'math\');\\n    const shapePlugin = engine.getPlugin(\'shape\');\\n    \\n    // 플러그인 기능 구현\\n    // ...\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 정리 코드\\n    console.log(\'MyCustomPlugin uninstalled\');\\n  }\\n  \\n  // 플러그인 메서드\\n  doSomething(): void {\\n    // ...\\n  }\\n}\\n```\\n\\n### 플러그인 의존성 관리\\n\\n플러그인은 다른 플러그인에 의존할 수 있습니다. 의존성은 `dependencies` 속성에 정의합니다:\\n\\n```typescript\\nreadonly dependencies = [\'math\', \'shape\'];\\n```\\n\\n의존성 플러그인은 `install` 메서드에서 접근할 수 있습니다:\\n\\n```typescript\\ninstall(engine: VectorEngine): void {\\n  const mathPlugin = engine.getPlugin<MathPlugin>(\'math\');\\n  const shapePlugin = engine.getPlugin<ShapePlugin>(\'shape\');\\n  \\n  // 의존성 플러그인 사용\\n  // ...\\n}\\n```\\n\\n### 플러그인 통신\\n\\n플러그인 간 통신은 다음과 같은 방법으로 이루어집니다:\\n\\n#### 1. 직접 접근\\n\\n다른 플러그인에 직접 접근하여 메서드를 호출합니다:\\n\\n```typescript\\nconst otherPlugin = engine.getPlugin<OtherPlugin>(\'other-plugin\');\\notherPlugin.someMethod();\\n```\\n\\n#### 2. 이벤트 기반 통신\\n\\n이벤트 서비스를 사용하여 이벤트 기반 통신을 구현합니다:\\n\\n```typescript\\n// 이벤트 발행\\ninstall(engine: VectorEngine): void {\\n  this.events = engine.events.createNamespace(\'my-plugin\');\\n  \\n  // 이벤트 발행\\n  this.events.emit(\'something-happened\', { data: \'value\' });\\n}\\n\\n// 이벤트 구독\\ninstall(engine: VectorEngine): void {\\n  const myPluginEvents = engine.events.createNamespace(\'my-plugin\');\\n  \\n  // 이벤트 구독\\n  myPluginEvents.on(\'something-happened\', (data) => {\\n    console.log(\'Event received:\', data);\\n  });\\n}\\n```\\n\\n#### 3. 서비스 기반 통신\\n\\n코어 서비스를 통한 통신:\\n\\n```typescript\\n// 씬 서비스 사용\\ninstall(engine: VectorEngine): void {\\n  const scene = engine.scene.getActive();\\n  scene.add(someObject);\\n}\\n```\\n\\n## 플러그인 모범 사례\\n\\n### 1. 최소한의 의존성\\n\\n플러그인은 필요한 최소한의 의존성만 가져야 합니다:\\n\\n```typescript\\n// 좋음: 필요한 의존성만 선언\\nreadonly dependencies = [\'math\'];\\n\\n// 나쁨: 불필요한 의존성 포함\\nreadonly dependencies = [\'math\', \'shape\', \'transform\', \'renderer\'];\\n```\\n\\n### 2. 명확한 인터페이스\\n\\n플러그인은 명확한 공개 인터페이스를 제공해야 합니다:\\n\\n```typescript\\n// 좋음: 명확한 인터페이스\\nexport interface MyPlugin extends Plugin {\\n  doSomething(param: string): void;\\n  getValue(): number;\\n}\\n\\n// 나쁨: 불명확한 인터페이스\\nexport class MyPlugin implements Plugin {\\n  // 공개 메서드와 내부 메서드가 혼합됨\\n  doSomething(param: string): void { /* ... */ }\\n  _internalMethod(): void { /* ... */ }\\n}\\n```\\n\\n### 3. 적절한 정리\\n\\n플러그인이 제거될 때 모든 리소스를 정리해야 합니다:\\n\\n```typescript\\ninstall(engine: VectorEngine): void {\\n  this.eventHandler = engine.events.on(\'some-event\', this.handleEvent);\\n}\\n\\nuninstall(engine: VectorEngine): void {\\n  // 이벤트 리스너 제거\\n  engine.events.off(\'some-event\', this.eventHandler);\\n  \\n  // 다른 리소스 정리\\n  // ...\\n}\\n```\\n\\n### 4. 버전 관리\\n\\n플러그인은 명확한 버전 관리를 해야 합니다:\\n\\n```typescript\\nreadonly version = \'1.2.3\'; // 메이저.마이너.패치\\n```\\n\\n### 5. 문서화\\n\\n플러그인은 잘 문서화되어야 합니다:\\n\\n```typescript\\n/**\\n * 사용자 정의 플러그인\\n * \\n * 이 플러그인은 특정 기능을 제공합니다.\\n * \\n * @example\\n * ```typescript\\n * const engine = new VectorEngine();\\n * engine.use(new MyCustomPlugin());\\n * const plugin = engine.getPlugin<MyCustomPlugin>(\'my-custom-plugin\');\\n * plugin.doSomething(\'hello\');\\n * ```\\n */\\nexport class MyCustomPlugin implements Plugin {\\n  // ...\\n}\\n```\\n\\n## 예제: 커스텀 플러그인 개발\\n\\n### 그리드 플러그인 예제\\n\\n다음은 그리드를 그리는 커스텀 플러그인의 예제입니다:\\n\\n```typescript\\nimport { Plugin, VectorEngine, Scene } from \'@modern-vector/core\';\\n\\nexport interface GridOptions {\\n  size: number;\\n  color: string;\\n  thickness: number;\\n}\\n\\nexport class GridPlugin implements Plugin {\\n  readonly id = \'grid\';\\n  readonly version = \'1.0.0\';\\n  readonly dependencies = [\'renderer\'];\\n  \\n  private options: GridOptions = {\\n    size: 20,\\n    color: \'#cccccc\',\\n    thickness: 1\\n  };\\n  \\n  private engine: VectorEngine | null = null;\\n  private renderHandler: any = null;\\n  \\n  install(engine: VectorEngine): void {\\n    this.engine = engine;\\n    \\n    // 렌더링 이벤트 구독\\n    this.renderHandler = engine.events.on(\'before-render\', this.renderGrid.bind(this));\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 이벤트 리스너 제거\\n    if (this.renderHandler) {\\n      engine.events.off(\'before-render\', this.renderHandler);\\n      this.renderHandler = null;\\n    }\\n    \\n    this.engine = null;\\n  }\\n  \\n  // 그리드 옵션 설정\\n  setOptions(options: Partial<GridOptions>): void {\\n    this.options = { ...this.options, ...options };\\n  }\\n  \\n  // 그리드 렌더링\\n  private renderGrid(scene: Scene): void {\\n    if (!this.engine) return;\\n    \\n    const renderer = this.engine.renderer;\\n    const context = renderer.getContext();\\n    \\n    if (!context || !(\'canvas\' in context)) return;\\n    \\n    const canvas = context.canvas;\\n    const width = canvas.width;\\n    const height = canvas.height;\\n    \\n    const { size, color, thickness } = this.options;\\n    \\n    context.save();\\n    context.strokeStyle = color;\\n    context.lineWidth = thickness;\\n    \\n    // 수직선 그리기\\n    for (let x = 0; x <= width; x += size) {\\n      context.beginPath();\\n      context.moveTo(x, 0);\\n      context.lineTo(x, height);\\n      context.stroke();\\n    }\\n    \\n    // 수평선 그리기\\n    for (let y = 0; y <= height; y += size) {\\n      context.beginPath();\\n      context.moveTo(0, y);\\n      context.lineTo(width, y);\\n      context.stroke();\\n    }\\n    \\n    context.restore();\\n  }\\n}\\n```\\n\\n### 사용 예제\\n\\n```typescript\\nimport { VectorEngine } from \'@modern-vector/core\';\\nimport { CanvasRenderer } from \'@modern-vector/renderers\';\\nimport { GridPlugin } from \'./grid-plugin\';\\n\\n// 엔진 초기화\\nconst engine = new VectorEngine();\\n\\n// 렌더러 등록\\nengine.use(new CanvasRenderer({\\n  canvas: document.getElementById(\'canvas\') as HTMLCanvasElement\\n}));\\n\\n// 그리드 플러그인 등록\\nengine.use(new GridPlugin());\\n\\n// 그리드 옵션 설정\\nconst gridPlugin = engine.getPlugin<GridPlugin>(\'grid\');\\ngridPlugin.setOptions({\\n  size: 30,\\n  color: \'#dddddd\',\\n  thickness: 0.5\\n});\\n\\n// 렌더링\\nengine.renderer.render();\\n```\\n\\n## 결론\\n\\nModern Vector.js의 플러그인 시스템은 확장성과 유연성을 제공하여 다양한 기능을 모듈화된 방식으로 구현할 수 있게 합니다. 플러그인 인터페이스를 구현하여 사용자 정의 기능을 쉽게 추가할 수 있으며, 의존성 관리와 플러그인 간 통신을 통해 복잡한 기능도 구현할 수 있습니다. ","html":"<h1>플러그인 시스템</h1>\\n<p>Modern Vector.js는 플러그인 기반 아키텍처를 채택하여 확장성과 유연성을 제공합니다. 이 문서에서는 플러그인 시스템의 구조, 작동 방식, 그리고 사용자 정의 플러그인 개발 방법에 대해 설명합니다.</p>\\n<h2>플러그인 아키텍처</h2>\\n<p>Modern Vector.js의 플러그인 아키텍처는 다음과 같은 구성 요소로 이루어져 있습니다:</p>\\n<ol>\\n<li><strong>Core Engine</strong>: 최소한의 기능을 제공하는 핵심 엔진</li>\\n<li><strong>Plugin Interface</strong>: 모든 플러그인이 구현해야 하는 인터페이스</li>\\n<li><strong>Plugin Registry</strong>: 플러그인을 등록하고 관리하는 레지스트리</li>\\n<li><strong>Service System</strong>: 플러그인 간 통신을 위한 서비스 시스템</li>\\n</ol>\\n<h3>Plugin 인터페이스</h3>\\n<p>모든 플러그인은 <code>Plugin</code> 인터페이스를 구현해야 합니다:</p>\\n<pre><code class=\\"language-typescript\\">interface Plugin {\\n  /**\\n   * 플러그인의 고유 식별자\\n   */\\n  readonly id: string;\\n  \\n  /**\\n   * 플러그인의 버전\\n   */\\n  readonly version: string;\\n  \\n  /**\\n   * 플러그인의 의존성 목록\\n   */\\n  readonly dependencies?: string[];\\n  \\n  /**\\n   * 플러그인을 엔진에 설치합니다.\\n   * \\n   * @param engine - 벡터 엔진 인스턴스\\n   */\\n  install(engine: VectorEngine): void;\\n  \\n  /**\\n   * 플러그인을 엔진에서 제거합니다.\\n   * \\n   * @param engine - 벡터 엔진 인스턴스\\n   */\\n  uninstall(engine: VectorEngine): void;\\n}\\n</code></pre>\\n<h2>플러그인 카테고리</h2>\\n<p>Modern Vector.js의 플러그인은 다음과 같은 카테고리로 나뉩니다:</p>\\n<h3>1. Core Plugins (기본 제공)</h3>\\n<p>코어 플러그인은 기본적인 벡터 그래픽 기능을 제공합니다:</p>\\n<ul>\\n<li><strong>MathPlugin</strong>: 벡터, 행렬, 기하학 연산 제공</li>\\n<li><strong>ShapePlugin</strong>: 기본 도형 생성 및 관리</li>\\n<li><strong>TransformPlugin</strong>: 변환(이동, 회전, 크기 조절 등) 기능 제공</li>\\n</ul>\\n<h3>2. Renderer Plugins</h3>\\n<p>렌더러 플러그인은 다양한 렌더링 백엔드를 지원합니다:</p>\\n<ul>\\n<li><strong>CanvasRendererPlugin</strong>: HTML Canvas 렌더링</li>\\n<li><strong>SVGRendererPlugin</strong>: SVG 렌더링</li>\\n<li><strong>WebGLRendererPlugin</strong>: WebGL 렌더링</li>\\n</ul>\\n<h3>3. Effect Plugins</h3>\\n<p>효과 플러그인은 시각적 효과를 제공합니다:</p>\\n<ul>\\n<li><strong>FilterPlugin</strong>: 필터 효과 (블러, 그림자 등)</li>\\n<li><strong>AnimationPlugin</strong>: 애니메이션 효과</li>\\n</ul>\\n<h3>4. Tool Plugins</h3>\\n<p>도구 플러그인은 사용자 상호작용 기능을 제공합니다:</p>\\n<ul>\\n<li><strong>SelectionToolPlugin</strong>: 객체 선택 도구</li>\\n<li><strong>TransformToolPlugin</strong>: 객체 변환 도구</li>\\n</ul>\\n<h2>플러그인 사용하기</h2>\\n<h3>플러그인 등록</h3>\\n<p>플러그인을 사용하려면 <code>VectorEngine</code>의 <code>use</code> 메서드를 사용하여 등록합니다:</p>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine } from \'@modern-vector/core\';\\nimport { CanvasRenderer, ShapePlugin, MathPlugin } from \'@modern-vector/plugins\';\\n\\n// 엔진 초기화\\nconst engine = new VectorEngine();\\n\\n// 플러그인 등록\\nengine.use(new MathPlugin());\\nengine.use(new CanvasRenderer());\\nengine.use(new ShapePlugin());\\n</code></pre>\\n<h3>플러그인 접근</h3>\\n<p>등록된 플러그인은 <code>getPlugin</code> 메서드를 사용하여 접근할 수 있습니다:</p>\\n<pre><code class=\\"language-typescript\\">// 플러그인 접근\\nconst shapePlugin = engine.getPlugin&#x3C;ShapePlugin>(\'shape\');\\nconst mathPlugin = engine.getPlugin&#x3C;MathPlugin>(\'math\');\\n\\n// 플러그인 사용\\nconst rect = shapePlugin.createRect({\\n  x: 100,\\n  y: 100,\\n  width: 200,\\n  height: 150\\n});\\n\\nconst vector = mathPlugin.vector.create(10, 20);\\n</code></pre>\\n<h3>플러그인 제거</h3>\\n<p>플러그인을 제거하려면 <code>remove</code> 메서드를 사용합니다:</p>\\n<pre><code class=\\"language-typescript\\">// 플러그인 제거\\nengine.remove(\'shape\');\\n</code></pre>\\n<h2>플러그인 개발하기</h2>\\n<h3>기본 플러그인 구현</h3>\\n<p>사용자 정의 플러그인을 개발하려면 <code>Plugin</code> 인터페이스를 구현하는 클래스를 작성합니다:</p>\\n<pre><code class=\\"language-typescript\\">import { Plugin, VectorEngine } from \'@modern-vector/core\';\\n\\nexport class MyCustomPlugin implements Plugin {\\n  readonly id = \'my-custom-plugin\';\\n  readonly version = \'1.0.0\';\\n  readonly dependencies = [\'math\', \'shape\'];\\n  \\n  install(engine: VectorEngine): void {\\n    // 플러그인 초기화 코드\\n    console.log(\'MyCustomPlugin installed\');\\n    \\n    // 의존성 플러그인 접근\\n    const mathPlugin = engine.getPlugin(\'math\');\\n    const shapePlugin = engine.getPlugin(\'shape\');\\n    \\n    // 플러그인 기능 구현\\n    // ...\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 정리 코드\\n    console.log(\'MyCustomPlugin uninstalled\');\\n  }\\n  \\n  // 플러그인 메서드\\n  doSomething(): void {\\n    // ...\\n  }\\n}\\n</code></pre>\\n<h3>플러그인 의존성 관리</h3>\\n<p>플러그인은 다른 플러그인에 의존할 수 있습니다. 의존성은 <code>dependencies</code> 속성에 정의합니다:</p>\\n<pre><code class=\\"language-typescript\\">readonly dependencies = [\'math\', \'shape\'];\\n</code></pre>\\n<p>의존성 플러그인은 <code>install</code> 메서드에서 접근할 수 있습니다:</p>\\n<pre><code class=\\"language-typescript\\">install(engine: VectorEngine): void {\\n  const mathPlugin = engine.getPlugin&#x3C;MathPlugin>(\'math\');\\n  const shapePlugin = engine.getPlugin&#x3C;ShapePlugin>(\'shape\');\\n  \\n  // 의존성 플러그인 사용\\n  // ...\\n}\\n</code></pre>\\n<h3>플러그인 통신</h3>\\n<p>플러그인 간 통신은 다음과 같은 방법으로 이루어집니다:</p>\\n<h4>1. 직접 접근</h4>\\n<p>다른 플러그인에 직접 접근하여 메서드를 호출합니다:</p>\\n<pre><code class=\\"language-typescript\\">const otherPlugin = engine.getPlugin&#x3C;OtherPlugin>(\'other-plugin\');\\notherPlugin.someMethod();\\n</code></pre>\\n<h4>2. 이벤트 기반 통신</h4>\\n<p>이벤트 서비스를 사용하여 이벤트 기반 통신을 구현합니다:</p>\\n<pre><code class=\\"language-typescript\\">// 이벤트 발행\\ninstall(engine: VectorEngine): void {\\n  this.events = engine.events.createNamespace(\'my-plugin\');\\n  \\n  // 이벤트 발행\\n  this.events.emit(\'something-happened\', { data: \'value\' });\\n}\\n\\n// 이벤트 구독\\ninstall(engine: VectorEngine): void {\\n  const myPluginEvents = engine.events.createNamespace(\'my-plugin\');\\n  \\n  // 이벤트 구독\\n  myPluginEvents.on(\'something-happened\', (data) => {\\n    console.log(\'Event received:\', data);\\n  });\\n}\\n</code></pre>\\n<h4>3. 서비스 기반 통신</h4>\\n<p>코어 서비스를 통한 통신:</p>\\n<pre><code class=\\"language-typescript\\">// 씬 서비스 사용\\ninstall(engine: VectorEngine): void {\\n  const scene = engine.scene.getActive();\\n  scene.add(someObject);\\n}\\n</code></pre>\\n<h2>플러그인 모범 사례</h2>\\n<h3>1. 최소한의 의존성</h3>\\n<p>플러그인은 필요한 최소한의 의존성만 가져야 합니다:</p>\\n<pre><code class=\\"language-typescript\\">// 좋음: 필요한 의존성만 선언\\nreadonly dependencies = [\'math\'];\\n\\n// 나쁨: 불필요한 의존성 포함\\nreadonly dependencies = [\'math\', \'shape\', \'transform\', \'renderer\'];\\n</code></pre>\\n<h3>2. 명확한 인터페이스</h3>\\n<p>플러그인은 명확한 공개 인터페이스를 제공해야 합니다:</p>\\n<pre><code class=\\"language-typescript\\">// 좋음: 명확한 인터페이스\\nexport interface MyPlugin extends Plugin {\\n  doSomething(param: string): void;\\n  getValue(): number;\\n}\\n\\n// 나쁨: 불명확한 인터페이스\\nexport class MyPlugin implements Plugin {\\n  // 공개 메서드와 내부 메서드가 혼합됨\\n  doSomething(param: string): void { /* ... */ }\\n  _internalMethod(): void { /* ... */ }\\n}\\n</code></pre>\\n<h3>3. 적절한 정리</h3>\\n<p>플러그인이 제거될 때 모든 리소스를 정리해야 합니다:</p>\\n<pre><code class=\\"language-typescript\\">install(engine: VectorEngine): void {\\n  this.eventHandler = engine.events.on(\'some-event\', this.handleEvent);\\n}\\n\\nuninstall(engine: VectorEngine): void {\\n  // 이벤트 리스너 제거\\n  engine.events.off(\'some-event\', this.eventHandler);\\n  \\n  // 다른 리소스 정리\\n  // ...\\n}\\n</code></pre>\\n<h3>4. 버전 관리</h3>\\n<p>플러그인은 명확한 버전 관리를 해야 합니다:</p>\\n<pre><code class=\\"language-typescript\\">readonly version = \'1.2.3\'; // 메이저.마이너.패치\\n</code></pre>\\n<h3>5. 문서화</h3>\\n<p>플러그인은 잘 문서화되어야 합니다:</p>\\n<pre><code class=\\"language-typescript\\">/**\\n * 사용자 정의 플러그인\\n * \\n * 이 플러그인은 특정 기능을 제공합니다.\\n * \\n * @example\\n * ```typescript\\n * const engine = new VectorEngine();\\n * engine.use(new MyCustomPlugin());\\n * const plugin = engine.getPlugin&#x3C;MyCustomPlugin>(\'my-custom-plugin\');\\n * plugin.doSomething(\'hello\');\\n * ```\\n */\\nexport class MyCustomPlugin implements Plugin {\\n  // ...\\n}\\n</code></pre>\\n<h2>예제: 커스텀 플러그인 개발</h2>\\n<h3>그리드 플러그인 예제</h3>\\n<p>다음은 그리드를 그리는 커스텀 플러그인의 예제입니다:</p>\\n<pre><code class=\\"language-typescript\\">import { Plugin, VectorEngine, Scene } from \'@modern-vector/core\';\\n\\nexport interface GridOptions {\\n  size: number;\\n  color: string;\\n  thickness: number;\\n}\\n\\nexport class GridPlugin implements Plugin {\\n  readonly id = \'grid\';\\n  readonly version = \'1.0.0\';\\n  readonly dependencies = [\'renderer\'];\\n  \\n  private options: GridOptions = {\\n    size: 20,\\n    color: \'#cccccc\',\\n    thickness: 1\\n  };\\n  \\n  private engine: VectorEngine | null = null;\\n  private renderHandler: any = null;\\n  \\n  install(engine: VectorEngine): void {\\n    this.engine = engine;\\n    \\n    // 렌더링 이벤트 구독\\n    this.renderHandler = engine.events.on(\'before-render\', this.renderGrid.bind(this));\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 이벤트 리스너 제거\\n    if (this.renderHandler) {\\n      engine.events.off(\'before-render\', this.renderHandler);\\n      this.renderHandler = null;\\n    }\\n    \\n    this.engine = null;\\n  }\\n  \\n  // 그리드 옵션 설정\\n  setOptions(options: Partial&#x3C;GridOptions>): void {\\n    this.options = { ...this.options, ...options };\\n  }\\n  \\n  // 그리드 렌더링\\n  private renderGrid(scene: Scene): void {\\n    if (!this.engine) return;\\n    \\n    const renderer = this.engine.renderer;\\n    const context = renderer.getContext();\\n    \\n    if (!context || !(\'canvas\' in context)) return;\\n    \\n    const canvas = context.canvas;\\n    const width = canvas.width;\\n    const height = canvas.height;\\n    \\n    const { size, color, thickness } = this.options;\\n    \\n    context.save();\\n    context.strokeStyle = color;\\n    context.lineWidth = thickness;\\n    \\n    // 수직선 그리기\\n    for (let x = 0; x &#x3C;= width; x += size) {\\n      context.beginPath();\\n      context.moveTo(x, 0);\\n      context.lineTo(x, height);\\n      context.stroke();\\n    }\\n    \\n    // 수평선 그리기\\n    for (let y = 0; y &#x3C;= height; y += size) {\\n      context.beginPath();\\n      context.moveTo(0, y);\\n      context.lineTo(width, y);\\n      context.stroke();\\n    }\\n    \\n    context.restore();\\n  }\\n}\\n</code></pre>\\n<h3>사용 예제</h3>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine } from \'@modern-vector/core\';\\nimport { CanvasRenderer } from \'@modern-vector/renderers\';\\nimport { GridPlugin } from \'./grid-plugin\';\\n\\n// 엔진 초기화\\nconst engine = new VectorEngine();\\n\\n// 렌더러 등록\\nengine.use(new CanvasRenderer({\\n  canvas: document.getElementById(\'canvas\') as HTMLCanvasElement\\n}));\\n\\n// 그리드 플러그인 등록\\nengine.use(new GridPlugin());\\n\\n// 그리드 옵션 설정\\nconst gridPlugin = engine.getPlugin&#x3C;GridPlugin>(\'grid\');\\ngridPlugin.setOptions({\\n  size: 30,\\n  color: \'#dddddd\',\\n  thickness: 0.5\\n});\\n\\n// 렌더링\\nengine.renderer.render();\\n</code></pre>\\n<h2>결론</h2>\\n<p>Modern Vector.js의 플러그인 시스템은 확장성과 유연성을 제공하여 다양한 기능을 모듈화된 방식으로 구현할 수 있게 합니다. 플러그인 인터페이스를 구현하여 사용자 정의 기능을 쉽게 추가할 수 있으며, 의존성 관리와 플러그인 간 통신을 통해 복잡한 기능도 구현할 수 있습니다.</p>"},"_id":"docs/core-concepts/plugin-system.md","_raw":{"sourceFilePath":"docs/core-concepts/plugin-system.md","sourceFileName":"plugin-system.md","sourceFileDir":"docs/core-concepts","contentType":"markdown","flattenedPath":"docs/core-concepts/plugin-system"},"type":"Doc","slug":"core-concepts/plugin-system","url":"/docs/core-concepts/plugin-system"},{"title":"GitHub Pages 배포","description":"Modern Vector.js 문서 사이트를 GitHub Pages에 배포하는 방법","body":{"raw":"\\n# GitHub Pages 배포\\n\\nModern Vector.js 문서 사이트는 GitHub Pages를 통해 배포됩니다. 이 문서에서는 GitHub Pages 배포 설정 방법과 자동화된 배포 워크플로우에 대해 설명합니다.\\n\\n## 배포 설정\\n\\n### GitHub Actions 워크플로우\\n\\nModern Vector.js는 GitHub Actions를 사용하여 문서 사이트를 자동으로 빌드하고 GitHub Pages에 배포합니다. 워크플로우 설정은 `.github/workflows/deploy-docs.yml` 파일에 정의되어 있습니다.\\n\\n```yaml\\nname: Deploy Docs to GitHub Pages\\n\\non:\\n  push:\\n    branches: [ main ]\\n  workflow_dispatch:\\n\\npermissions:\\n  contents: read\\n  pages: write\\n  id-token: write\\n\\nconcurrency:\\n  group: \\"pages\\"\\n  cancel-in-progress: false\\n\\njobs:\\n  build:\\n    runs-on: ubuntu-latest\\n    steps:\\n      - name: Checkout\\n        uses: actions/checkout@v4\\n      \\n      - name: Setup Node.js\\n        uses: actions/setup-node@v4\\n        with:\\n          node-version: \'20\'\\n      \\n      - name: Setup pnpm\\n        uses: pnpm/action-setup@v2\\n        with:\\n          version: 8\\n          run_install: false\\n      \\n      - name: Install dependencies\\n        run: pnpm install --no-frozen-lockfile\\n      \\n      - name: Build core package\\n        run: cd packages/core && pnpm build\\n      \\n      - name: Build docs site\\n        run: cd packages/docs-site && pnpm build\\n      \\n      - name: Setup Pages\\n        uses: actions/configure-pages@v3\\n      \\n      - name: Upload artifact\\n        uses: actions/upload-pages-artifact@v3\\n        with:\\n          path: ./packages/docs-site/dist\\n\\n  deploy:\\n    environment:\\n      name: github-pages\\n      url: ${{ steps.deployment.outputs.page_url }}\\n    runs-on: ubuntu-latest\\n    needs: build\\n    steps:\\n      - name: Deploy to GitHub Pages\\n        id: deployment\\n        uses: actions/deploy-pages@v2\\n```\\n\\n이 워크플로우는 다음과 같은 작업을 수행합니다:\\n\\n1. `main` 브랜치에 푸시하거나 수동으로 워크플로우를 트리거할 때 실행됩니다.\\n2. 저장소를 체크아웃하고 Node.js와 pnpm을 설정합니다.\\n3. 의존성을 설치하고 core 패키지와 docs-site 패키지를 빌드합니다.\\n4. 빌드된 문서 사이트를 GitHub Pages에 배포합니다.\\n\\n### Next.js 설정\\n\\nGitHub Pages에서 Next.js 애플리케이션을 올바르게 실행하려면 `next.config.js` 파일에 다음과 같은 설정이 필요합니다:\\n\\n```javascript\\n/** @type {import(\'next\').NextConfig} */\\nconst nextConfig = {\\n  output: \'export\',\\n  distDir: \'dist\',\\n  images: {\\n    unoptimized: true,\\n  },\\n  basePath: process.env.NODE_ENV === \'production\' ? \'/modern-vector.js\' : \'\',\\n  assetPrefix: process.env.NODE_ENV === \'production\' ? \'/modern-vector.js/\' : \'\',\\n};\\n\\nmodule.exports = nextConfig;\\n```\\n\\n- `output: \'export\'`: 정적 HTML 파일로 내보내기\\n- `distDir: \'dist\'`: 빌드 결과물을 `dist` 디렉토리에 저장\\n- `basePath`: GitHub Pages의 저장소 이름에 맞게 기본 경로 설정\\n- `assetPrefix`: 정적 자산(CSS, JavaScript 등)의 경로 접두사 설정\\n\\n## SPA 라우팅 지원\\n\\nGitHub Pages는 기본적으로 SPA(Single Page Application) 라우팅을 지원하지 않습니다. 이를 해결하기 위해 다음과 같은 설정이 필요합니다:\\n\\n### 404.html 페이지\\n\\n`public/404.html` 파일을 생성하여 클라이언트 측 라우팅을 지원합니다:\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n  <meta charset=\\"UTF-8\\">\\n  <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n  <title>Page Not Found</title>\\n  <script>\\n    // SPA를 위한 리다이렉션 스크립트\\n    (function() {\\n      // 현재 URL 가져오기\\n      var location = window.location;\\n      var pathname = location.pathname;\\n      \\n      // 저장소 이름 (GitHub Pages 경로)\\n      var repoName = \'modern-vector.js\';\\n      \\n      // 저장소 이름으로 시작하는 경로인지 확인\\n      var pathSegments = pathname.split(\'/\');\\n      var isInRepo = pathSegments[1] === repoName;\\n      \\n      // 새 URL 구성\\n      var redirectUrl = location.origin;\\n      \\n      if (isInRepo) {\\n        redirectUrl += \'/\' + repoName;\\n        \\n        // 쿼리 파라미터로 원래 경로 전달\\n        var path = pathname.replace(\'/\' + repoName, \'\');\\n        if (path) {\\n          redirectUrl += \'?path=\' + encodeURIComponent(path);\\n        }\\n      }\\n      \\n      // 리다이렉션\\n      window.location.replace(redirectUrl);\\n    })();\\n  <\/script>\\n</head>\\n<body>\\n  <div class=\\"container\\">\\n    <h1>페이지를 찾을 수 없습니다</h1>\\n    <p>요청하신 페이지를 찾을 수 없습니다. 홈페이지로 리다이렉션됩니다.</p>\\n  </div>\\n</body>\\n</html>\\n```\\n\\n### GitHubPagesRedirect 컴포넌트\\n\\n`src/components/github-pages-redirect.tsx` 파일을 생성하여 404 페이지에서 전달된 경로로 리다이렉션합니다:\\n\\n```tsx\\n\'use client\';\\n\\nimport { useEffect } from \'react\';\\nimport { useRouter, useSearchParams } from \'next/navigation\';\\n\\n/**\\n * GitHub Pages에서 SPA 라우팅을 지원하기 위한 리다이렉션 컴포넌트\\n * 404.html에서 전달된 path 파라미터를 사용하여 적절한 경로로 리다이렉션합니다.\\n */\\nexport function GitHubPagesRedirect() {\\n  const router = useRouter();\\n  const searchParams = useSearchParams();\\n  \\n  useEffect(() => {\\n    // URL에서 path 파라미터 확인\\n    const path = searchParams.get(\'path\');\\n    \\n    // path 파라미터가 있으면 해당 경로로 리다이렉션\\n    if (path) {\\n      router.replace(path);\\n    }\\n  }, [router, searchParams]);\\n  \\n  // 이 컴포넌트는 UI를 렌더링하지 않음\\n  return null;\\n}\\n```\\n\\n### 레이아웃에 컴포넌트 추가\\n\\n`src/app/layout.tsx` 파일에 `GitHubPagesRedirect` 컴포넌트를 추가합니다:\\n\\n```tsx\\nimport { GitHubPagesRedirect } from \'@/components/github-pages-redirect\';\\n\\nexport default function RootLayout({\\n  children,\\n}: {\\n  children: React.ReactNode;\\n}) {\\n  return (\\n    <html lang=\\"en\\">\\n      <body>\\n        <GitHubPagesRedirect />\\n        {children}\\n      </body>\\n    </html>\\n  );\\n}\\n```\\n\\n## GitHub Pages 설정\\n\\nGitHub 저장소 설정에서 Pages 기능을 활성화하고 배포 소스를 설정해야 합니다:\\n\\n1. GitHub 저장소 페이지로 이동\\n2. \\"Settings\\" 탭 클릭\\n3. 왼쪽 사이드바에서 \\"Pages\\" 클릭\\n4. \\"Build and deployment\\" 섹션에서:\\n   - Source: \\"GitHub Actions\\"를 선택\\n\\n## 수동 배포\\n\\nGitHub Actions 워크플로우를 수동으로 트리거하여 문서 사이트를 배포할 수 있습니다:\\n\\n1. GitHub 저장소의 \\"Actions\\" 탭으로 이동\\n2. 왼쪽 사이드바에서 \\"Deploy Docs to GitHub Pages\\" 워크플로우 선택\\n3. 오른쪽 상단의 \\"Run workflow\\" 버튼 클릭\\n4. \\"Run workflow\\" 대화 상자에서 \\"Run workflow\\" 버튼 클릭\\n\\n## 배포 확인\\n\\n배포가 완료되면 `https://username.github.io/modern-vector.js/` 주소에서 문서 사이트를 확인할 수 있습니다.\\n\\n## 문제 해결\\n\\n### 404 오류\\n\\nGitHub Pages에서 404 오류가 발생하는 경우:\\n\\n1. `.github/workflows/deploy-docs.yml` 파일이 올바르게 설정되어 있는지 확인\\n2. `next.config.js` 파일에서 `basePath`와 `assetPrefix`가 올바르게 설정되어 있는지 확인\\n3. `public/404.html` 파일이 존재하고 올바르게 설정되어 있는지 확인\\n4. GitHub 저장소 설정에서 Pages 기능이 활성화되어 있는지 확인\\n\\n### 정적 자산 로드 실패\\n\\n정적 자산(CSS, JavaScript 등)이 로드되지 않는 경우:\\n\\n1. `next.config.js` 파일에서 `assetPrefix`가 올바르게 설정되어 있는지 확인\\n2. 브라우저 개발자 도구에서 네트워크 탭을 확인하여 정적 자산의 URL이 올바른지 확인\\n\\n### 클라이언트 측 라우팅 문제\\n\\n클라이언트 측 라우팅이 작동하지 않는 경우:\\n\\n1. `public/404.html` 파일이 올바르게 설정되어 있는지 확인\\n2. `src/components/github-pages-redirect.tsx` 파일이 올바르게 구현되어 있는지 확인\\n3. `src/app/layout.tsx` 파일에 `GitHubPagesRedirect` 컴포넌트가 추가되어 있는지 확인 ","html":"<h1>GitHub Pages 배포</h1>\\n<p>Modern Vector.js 문서 사이트는 GitHub Pages를 통해 배포됩니다. 이 문서에서는 GitHub Pages 배포 설정 방법과 자동화된 배포 워크플로우에 대해 설명합니다.</p>\\n<h2>배포 설정</h2>\\n<h3>GitHub Actions 워크플로우</h3>\\n<p>Modern Vector.js는 GitHub Actions를 사용하여 문서 사이트를 자동으로 빌드하고 GitHub Pages에 배포합니다. 워크플로우 설정은 <code>.github/workflows/deploy-docs.yml</code> 파일에 정의되어 있습니다.</p>\\n<pre><code class=\\"language-yaml\\">name: Deploy Docs to GitHub Pages\\n\\non:\\n  push:\\n    branches: [ main ]\\n  workflow_dispatch:\\n\\npermissions:\\n  contents: read\\n  pages: write\\n  id-token: write\\n\\nconcurrency:\\n  group: \\"pages\\"\\n  cancel-in-progress: false\\n\\njobs:\\n  build:\\n    runs-on: ubuntu-latest\\n    steps:\\n      - name: Checkout\\n        uses: actions/checkout@v4\\n      \\n      - name: Setup Node.js\\n        uses: actions/setup-node@v4\\n        with:\\n          node-version: \'20\'\\n      \\n      - name: Setup pnpm\\n        uses: pnpm/action-setup@v2\\n        with:\\n          version: 8\\n          run_install: false\\n      \\n      - name: Install dependencies\\n        run: pnpm install --no-frozen-lockfile\\n      \\n      - name: Build core package\\n        run: cd packages/core &#x26;&#x26; pnpm build\\n      \\n      - name: Build docs site\\n        run: cd packages/docs-site &#x26;&#x26; pnpm build\\n      \\n      - name: Setup Pages\\n        uses: actions/configure-pages@v3\\n      \\n      - name: Upload artifact\\n        uses: actions/upload-pages-artifact@v3\\n        with:\\n          path: ./packages/docs-site/dist\\n\\n  deploy:\\n    environment:\\n      name: github-pages\\n      url: ${{ steps.deployment.outputs.page_url }}\\n    runs-on: ubuntu-latest\\n    needs: build\\n    steps:\\n      - name: Deploy to GitHub Pages\\n        id: deployment\\n        uses: actions/deploy-pages@v2\\n</code></pre>\\n<p>이 워크플로우는 다음과 같은 작업을 수행합니다:</p>\\n<ol>\\n<li><code>main</code> 브랜치에 푸시하거나 수동으로 워크플로우를 트리거할 때 실행됩니다.</li>\\n<li>저장소를 체크아웃하고 Node.js와 pnpm을 설정합니다.</li>\\n<li>의존성을 설치하고 core 패키지와 docs-site 패키지를 빌드합니다.</li>\\n<li>빌드된 문서 사이트를 GitHub Pages에 배포합니다.</li>\\n</ol>\\n<h3>Next.js 설정</h3>\\n<p>GitHub Pages에서 Next.js 애플리케이션을 올바르게 실행하려면 <code>next.config.js</code> 파일에 다음과 같은 설정이 필요합니다:</p>\\n<pre><code class=\\"language-javascript\\">/** @type {import(\'next\').NextConfig} */\\nconst nextConfig = {\\n  output: \'export\',\\n  distDir: \'dist\',\\n  images: {\\n    unoptimized: true,\\n  },\\n  basePath: process.env.NODE_ENV === \'production\' ? \'/modern-vector.js\' : \'\',\\n  assetPrefix: process.env.NODE_ENV === \'production\' ? \'/modern-vector.js/\' : \'\',\\n};\\n\\nmodule.exports = nextConfig;\\n</code></pre>\\n<ul>\\n<li><code>output: \'export\'</code>: 정적 HTML 파일로 내보내기</li>\\n<li><code>distDir: \'dist\'</code>: 빌드 결과물을 <code>dist</code> 디렉토리에 저장</li>\\n<li><code>basePath</code>: GitHub Pages의 저장소 이름에 맞게 기본 경로 설정</li>\\n<li><code>assetPrefix</code>: 정적 자산(CSS, JavaScript 등)의 경로 접두사 설정</li>\\n</ul>\\n<h2>SPA 라우팅 지원</h2>\\n<p>GitHub Pages는 기본적으로 SPA(Single Page Application) 라우팅을 지원하지 않습니다. 이를 해결하기 위해 다음과 같은 설정이 필요합니다:</p>\\n<h3>404.html 페이지</h3>\\n<p><code>public/404.html</code> 파일을 생성하여 클라이언트 측 라우팅을 지원합니다:</p>\\n<pre><code class=\\"language-html\\">&#x3C;!DOCTYPE html>\\n&#x3C;html lang=\\"en\\">\\n&#x3C;head>\\n  &#x3C;meta charset=\\"UTF-8\\">\\n  &#x3C;meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n  &#x3C;title>Page Not Found&#x3C;/title>\\n  &#x3C;script>\\n    // SPA를 위한 리다이렉션 스크립트\\n    (function() {\\n      // 현재 URL 가져오기\\n      var location = window.location;\\n      var pathname = location.pathname;\\n      \\n      // 저장소 이름 (GitHub Pages 경로)\\n      var repoName = \'modern-vector.js\';\\n      \\n      // 저장소 이름으로 시작하는 경로인지 확인\\n      var pathSegments = pathname.split(\'/\');\\n      var isInRepo = pathSegments[1] === repoName;\\n      \\n      // 새 URL 구성\\n      var redirectUrl = location.origin;\\n      \\n      if (isInRepo) {\\n        redirectUrl += \'/\' + repoName;\\n        \\n        // 쿼리 파라미터로 원래 경로 전달\\n        var path = pathname.replace(\'/\' + repoName, \'\');\\n        if (path) {\\n          redirectUrl += \'?path=\' + encodeURIComponent(path);\\n        }\\n      }\\n      \\n      // 리다이렉션\\n      window.location.replace(redirectUrl);\\n    })();\\n  &#x3C;/script>\\n&#x3C;/head>\\n&#x3C;body>\\n  &#x3C;div class=\\"container\\">\\n    &#x3C;h1>페이지를 찾을 수 없습니다&#x3C;/h1>\\n    &#x3C;p>요청하신 페이지를 찾을 수 없습니다. 홈페이지로 리다이렉션됩니다.&#x3C;/p>\\n  &#x3C;/div>\\n&#x3C;/body>\\n&#x3C;/html>\\n</code></pre>\\n<h3>GitHubPagesRedirect 컴포넌트</h3>\\n<p><code>src/components/github-pages-redirect.tsx</code> 파일을 생성하여 404 페이지에서 전달된 경로로 리다이렉션합니다:</p>\\n<pre><code class=\\"language-tsx\\">\'use client\';\\n\\nimport { useEffect } from \'react\';\\nimport { useRouter, useSearchParams } from \'next/navigation\';\\n\\n/**\\n * GitHub Pages에서 SPA 라우팅을 지원하기 위한 리다이렉션 컴포넌트\\n * 404.html에서 전달된 path 파라미터를 사용하여 적절한 경로로 리다이렉션합니다.\\n */\\nexport function GitHubPagesRedirect() {\\n  const router = useRouter();\\n  const searchParams = useSearchParams();\\n  \\n  useEffect(() => {\\n    // URL에서 path 파라미터 확인\\n    const path = searchParams.get(\'path\');\\n    \\n    // path 파라미터가 있으면 해당 경로로 리다이렉션\\n    if (path) {\\n      router.replace(path);\\n    }\\n  }, [router, searchParams]);\\n  \\n  // 이 컴포넌트는 UI를 렌더링하지 않음\\n  return null;\\n}\\n</code></pre>\\n<h3>레이아웃에 컴포넌트 추가</h3>\\n<p><code>src/app/layout.tsx</code> 파일에 <code>GitHubPagesRedirect</code> 컴포넌트를 추가합니다:</p>\\n<pre><code class=\\"language-tsx\\">import { GitHubPagesRedirect } from \'@/components/github-pages-redirect\';\\n\\nexport default function RootLayout({\\n  children,\\n}: {\\n  children: React.ReactNode;\\n}) {\\n  return (\\n    &#x3C;html lang=\\"en\\">\\n      &#x3C;body>\\n        &#x3C;GitHubPagesRedirect />\\n        {children}\\n      &#x3C;/body>\\n    &#x3C;/html>\\n  );\\n}\\n</code></pre>\\n<h2>GitHub Pages 설정</h2>\\n<p>GitHub 저장소 설정에서 Pages 기능을 활성화하고 배포 소스를 설정해야 합니다:</p>\\n<ol>\\n<li>GitHub 저장소 페이지로 이동</li>\\n<li>\\"Settings\\" 탭 클릭</li>\\n<li>왼쪽 사이드바에서 \\"Pages\\" 클릭</li>\\n<li>\\"Build and deployment\\" 섹션에서:\\n<ul>\\n<li>Source: \\"GitHub Actions\\"를 선택</li>\\n</ul>\\n</li>\\n</ol>\\n<h2>수동 배포</h2>\\n<p>GitHub Actions 워크플로우를 수동으로 트리거하여 문서 사이트를 배포할 수 있습니다:</p>\\n<ol>\\n<li>GitHub 저장소의 \\"Actions\\" 탭으로 이동</li>\\n<li>왼쪽 사이드바에서 \\"Deploy Docs to GitHub Pages\\" 워크플로우 선택</li>\\n<li>오른쪽 상단의 \\"Run workflow\\" 버튼 클릭</li>\\n<li>\\"Run workflow\\" 대화 상자에서 \\"Run workflow\\" 버튼 클릭</li>\\n</ol>\\n<h2>배포 확인</h2>\\n<p>배포가 완료되면 <code>https://username.github.io/modern-vector.js/</code> 주소에서 문서 사이트를 확인할 수 있습니다.</p>\\n<h2>문제 해결</h2>\\n<h3>404 오류</h3>\\n<p>GitHub Pages에서 404 오류가 발생하는 경우:</p>\\n<ol>\\n<li><code>.github/workflows/deploy-docs.yml</code> 파일이 올바르게 설정되어 있는지 확인</li>\\n<li><code>next.config.js</code> 파일에서 <code>basePath</code>와 <code>assetPrefix</code>가 올바르게 설정되어 있는지 확인</li>\\n<li><code>public/404.html</code> 파일이 존재하고 올바르게 설정되어 있는지 확인</li>\\n<li>GitHub 저장소 설정에서 Pages 기능이 활성화되어 있는지 확인</li>\\n</ol>\\n<h3>정적 자산 로드 실패</h3>\\n<p>정적 자산(CSS, JavaScript 등)이 로드되지 않는 경우:</p>\\n<ol>\\n<li><code>next.config.js</code> 파일에서 <code>assetPrefix</code>가 올바르게 설정되어 있는지 확인</li>\\n<li>브라우저 개발자 도구에서 네트워크 탭을 확인하여 정적 자산의 URL이 올바른지 확인</li>\\n</ol>\\n<h3>클라이언트 측 라우팅 문제</h3>\\n<p>클라이언트 측 라우팅이 작동하지 않는 경우:</p>\\n<ol>\\n<li><code>public/404.html</code> 파일이 올바르게 설정되어 있는지 확인</li>\\n<li><code>src/components/github-pages-redirect.tsx</code> 파일이 올바르게 구현되어 있는지 확인</li>\\n<li><code>src/app/layout.tsx</code> 파일에 <code>GitHubPagesRedirect</code> 컴포넌트가 추가되어 있는지 확인</li>\\n</ol>"},"_id":"docs/deployment/github-pages.md","_raw":{"sourceFilePath":"docs/deployment/github-pages.md","sourceFileName":"github-pages.md","sourceFileDir":"docs/deployment","contentType":"markdown","flattenedPath":"docs/deployment/github-pages"},"type":"Doc","slug":"deployment/github-pages","url":"/docs/deployment/github-pages"},{"title":"프로젝트 구조","description":"Modern Vector.js 프로젝트의 구조와 아키텍처 설명","body":{"raw":"\\n# 프로젝트 구조\\n\\nModern Vector.js는 모노레포 구조로 구성되어 있으며, 여러 패키지로 나뉘어 있습니다. 이 문서에서는 프로젝트의 전체 구조와 각 패키지의 역할에 대해 설명합니다.\\n\\n## 모노레포 구조\\n\\nModern Vector.js는 Turborepo와 pnpm workspace를 사용한 모노레포로 구성되어 있습니다. 이 구조는 다음과 같은 이점을 제공합니다:\\n\\n- **코드 공유**: 패키지 간 코드 공유 및 의존성 관리 용이\\n- **빌드 최적화**: Turborepo를 통한 빌드 캐싱 및 병렬 처리\\n- **일관된 개발 환경**: 모든 패키지에 동일한 개발 환경 적용\\n- **통합 테스트**: 패키지 간 통합 테스트 용이\\n\\n### 루트 디렉토리 구조\\n\\n```\\nmodern-vector.js/\\n├── .github/                # GitHub 관련 설정\\n│   └── workflows/          # GitHub Actions 워크플로우\\n├── packages/               # 패키지 디렉토리\\n│   ├── core/               # 코어 라이브러리\\n│   └── docs-site/          # 문서 사이트\\n├── .husky/                 # Git hooks 설정\\n├── .eslintrc.json          # ESLint 설정\\n├── .prettierrc             # Prettier 설정\\n├── .gitignore              # Git 무시 파일 목록\\n├── pnpm-workspace.yaml     # pnpm workspace 설정\\n├── turbo.json              # Turborepo 설정\\n├── package.json            # 루트 패키지 설정\\n└── README.md               # 프로젝트 설명\\n```\\n\\n### pnpm Workspace 설정\\n\\n`pnpm-workspace.yaml` 파일은 워크스페이스에 포함된 패키지를 정의합니다:\\n\\n```yaml\\npackages:\\n  - \'packages/*\'\\n```\\n\\n### Turborepo 설정\\n\\n`turbo.json` 파일은 Turborepo 파이프라인을 정의합니다:\\n\\n```json\\n{\\n  \\"$schema\\": \\"https://turbo.build/schema.json\\",\\n  \\"globalDependencies\\": [\\"**/.env.*local\\"],\\n  \\"pipeline\\": {\\n    \\"build\\": {\\n      \\"dependsOn\\": [\\"^build\\"],\\n      \\"outputs\\": [\\"dist/**\\", \\".next/**\\", \\"!.next/cache/**\\"]\\n    },\\n    \\"lint\\": {},\\n    \\"dev\\": {\\n      \\"cache\\": false,\\n      \\"persistent\\": true\\n    },\\n    \\"test\\": {\\n      \\"dependsOn\\": [\\"build\\"],\\n      \\"inputs\\": [\\"src/**/*.tsx\\", \\"src/**/*.ts\\", \\"test/**/*.ts\\", \\"test/**/*.tsx\\"]\\n    }\\n  }\\n}\\n```\\n\\n## Core 패키지\\n\\nCore 패키지는 Modern Vector.js의 핵심 라이브러리를 포함합니다. 이 패키지는 플러그인 기반 아키텍처를 구현하고 벡터 그래픽 시스템의 기본 기능을 제공합니다.\\n\\n### 디렉토리 구조\\n\\n```\\npackages/core/\\n├── src/                    # 소스 코드\\n│   ├── core/               # 코어 시스템\\n│   │   ├── engine.ts       # VectorEngine 구현\\n│   │   ├── services/       # 코어 서비스\\n│   │   │   ├── renderer.ts # RendererService\\n│   │   │   ├── events.ts   # EventService\\n│   │   │   └── scene.ts    # SceneService\\n│   │   └── types/          # 타입 정의\\n│   ├── plugins/            # 플러그인\\n│   │   ├── core/           # 코어 플러그인\\n│   │   └── renderers/      # 렌더러 플러그인\\n│   ├── performance/        # 성능 최적화\\n│   └── index.ts            # 진입점\\n├── dist/                   # 빌드 결과물\\n├── typedoc.json            # TypeDoc 설정\\n├── vite.config.ts          # Vite 설정\\n├── vitest.config.ts        # Vitest 설정\\n├── tsconfig.json           # TypeScript 설정\\n└── package.json            # 패키지 설정\\n```\\n\\n### 핵심 모듈\\n\\n#### Core System\\n\\nCore System은 Modern Vector.js의 핵심 기능을 구현합니다:\\n\\n- **VectorEngine**: 플러그인 관리 및 핵심 서비스 제공\\n- **Services**: 렌더링, 이벤트, 씬 관리 등의 핵심 서비스\\n- **Types**: 인터페이스, 타입, 열거형 등의 타입 정의\\n\\n#### Plugins\\n\\nPlugins는 Modern Vector.js의 기능을 확장하는 플러그인을 구현합니다:\\n\\n- **Core Plugins**: Math, Shape, Transform 등의 기본 플러그인\\n- **Renderer Plugins**: Canvas, SVG, WebGL 등의 렌더러 플러그인\\n\\n## Docs Site 패키지\\n\\nDocs Site 패키지는 Modern Vector.js의 문서 사이트를 구현합니다. 이 패키지는 Next.js, Tailwind CSS, shadcn/ui를 사용하여 구축되었으며, TypeDoc으로 생성된 API 문서를 포함합니다.\\n\\n### 디렉토리 구조\\n\\n```\\npackages/docs-site/\\n├── public/                 # 정적 파일\\n│   ├── api-docs/           # TypeDoc으로 생성된 API 문서\\n│   └── 404.html            # GitHub Pages SPA 라우팅을 위한 404 페이지\\n├── src/                    # 소스 코드\\n│   ├── app/                # Next.js 앱 라우터\\n│   │   ├── layout.tsx      # 레이아웃 컴포넌트\\n│   │   ├── page.tsx        # 홈페이지\\n│   │   ├── docs/           # 문서 페이지\\n│   │   ├── examples/       # 예제 페이지\\n│   │   └── api/            # API 문서 페이지\\n│   ├── components/         # 재사용 가능한 컴포넌트\\n│   │   ├── ui/             # UI 컴포넌트\\n│   │   ├── code-blocks/    # 코드 블록 컴포넌트\\n│   │   ├── navigation/     # 네비게이션 컴포넌트\\n│   │   └── github-pages-redirect.tsx  # GitHub Pages SPA 라우팅 지원\\n│   ├── lib/                # 유틸리티 함수\\n│   └── types/              # TypeScript 타입 정의\\n├── scripts/                # 스크립트\\n│   └── generate-docs.js    # API 문서 생성 스크립트\\n├── dist/                   # 빌드 결과물\\n├── next.config.js          # Next.js 설정\\n├── contentlayer.config.js  # ContentLayer 설정\\n├── tailwind.config.js      # Tailwind CSS 설정\\n├── tsconfig.json           # TypeScript 설정\\n└── package.json            # 패키지 설정\\n```\\n\\n### 주요 기능\\n\\n#### 문서 페이지\\n\\n문서 페이지는 Modern Vector.js의 사용법, API, 예제 등을 설명합니다:\\n\\n- **Getting Started**: 시작하기 가이드\\n- **Core Concepts**: 핵심 개념 설명\\n- **API Reference**: API 문서\\n- **Examples**: 예제 코드\\n\\n#### 예제 페이지\\n\\n예제 페이지는 Modern Vector.js의 다양한 기능을 보여주는 인터랙티브 예제를 제공합니다:\\n\\n- **Basic Shapes**: 기본 도형 그리기\\n- **Transformations**: 변환 적용하기\\n- **Path Operations**: 경로 연산\\n- **Plugins**: 플러그인 사용하기\\n\\n#### API 문서\\n\\nAPI 문서는 TypeDoc을 사용하여 자동으로 생성된 API 레퍼런스를 제공합니다:\\n\\n- **Classes**: 클래스 문서\\n- **Interfaces**: 인터페이스 문서\\n- **Types**: 타입 문서\\n- **Functions**: 함수 문서\\n\\n## 개발 워크플로우\\n\\n### 로컬 개발\\n\\n로컬 개발을 위한 명령어:\\n\\n```bash\\n# 모든 패키지 개발 서버 실행\\npnpm dev\\n\\n# 특정 패키지 개발 서버 실행\\npnpm --filter @modern-vector/core dev\\npnpm --filter docs-site dev\\n```\\n\\n### 빌드\\n\\n빌드를 위한 명령어:\\n\\n```bash\\n# 모든 패키지 빌드\\npnpm build\\n\\n# 특정 패키지 빌드\\npnpm --filter @modern-vector/core build\\npnpm --filter docs-site build\\n```\\n\\n### 테스트\\n\\n테스트를 위한 명령어:\\n\\n```bash\\n# 모든 패키지 테스트\\npnpm test\\n\\n# 특정 패키지 테스트\\npnpm --filter @modern-vector/core test\\n```\\n\\n### 린트\\n\\n린트를 위한 명령어:\\n\\n```bash\\n# 모든 패키지 린트\\npnpm lint\\n\\n# 특정 패키지 린트\\npnpm --filter @modern-vector/core lint\\npnpm --filter docs-site lint\\n```\\n\\n## 배포\\n\\n### Core 패키지 배포\\n\\nCore 패키지는 npm에 배포됩니다:\\n\\n```bash\\n# 버전 업데이트\\ncd packages/core\\npnpm version patch|minor|major\\n\\n# 배포\\npnpm publish\\n```\\n\\n### Docs Site 배포\\n\\nDocs Site는 GitHub Pages에 배포됩니다:\\n\\n```bash\\n# 수동 배포\\ncd packages/docs-site\\npnpm build\\npnpm deploy\\n```\\n\\n또는 GitHub Actions를 통한 자동 배포:\\n\\n1. `main` 브랜치에 변경사항 푸시\\n2. GitHub Actions 워크플로우 실행\\n3. GitHub Pages에 배포 ","html":"<h1>프로젝트 구조</h1>\\n<p>Modern Vector.js는 모노레포 구조로 구성되어 있으며, 여러 패키지로 나뉘어 있습니다. 이 문서에서는 프로젝트의 전체 구조와 각 패키지의 역할에 대해 설명합니다.</p>\\n<h2>모노레포 구조</h2>\\n<p>Modern Vector.js는 Turborepo와 pnpm workspace를 사용한 모노레포로 구성되어 있습니다. 이 구조는 다음과 같은 이점을 제공합니다:</p>\\n<ul>\\n<li><strong>코드 공유</strong>: 패키지 간 코드 공유 및 의존성 관리 용이</li>\\n<li><strong>빌드 최적화</strong>: Turborepo를 통한 빌드 캐싱 및 병렬 처리</li>\\n<li><strong>일관된 개발 환경</strong>: 모든 패키지에 동일한 개발 환경 적용</li>\\n<li><strong>통합 테스트</strong>: 패키지 간 통합 테스트 용이</li>\\n</ul>\\n<h3>루트 디렉토리 구조</h3>\\n<pre><code>modern-vector.js/\\n├── .github/                # GitHub 관련 설정\\n│   └── workflows/          # GitHub Actions 워크플로우\\n├── packages/               # 패키지 디렉토리\\n│   ├── core/               # 코어 라이브러리\\n│   └── docs-site/          # 문서 사이트\\n├── .husky/                 # Git hooks 설정\\n├── .eslintrc.json          # ESLint 설정\\n├── .prettierrc             # Prettier 설정\\n├── .gitignore              # Git 무시 파일 목록\\n├── pnpm-workspace.yaml     # pnpm workspace 설정\\n├── turbo.json              # Turborepo 설정\\n├── package.json            # 루트 패키지 설정\\n└── README.md               # 프로젝트 설명\\n</code></pre>\\n<h3>pnpm Workspace 설정</h3>\\n<p><code>pnpm-workspace.yaml</code> 파일은 워크스페이스에 포함된 패키지를 정의합니다:</p>\\n<pre><code class=\\"language-yaml\\">packages:\\n  - \'packages/*\'\\n</code></pre>\\n<h3>Turborepo 설정</h3>\\n<p><code>turbo.json</code> 파일은 Turborepo 파이프라인을 정의합니다:</p>\\n<pre><code class=\\"language-json\\">{\\n  \\"$schema\\": \\"https://turbo.build/schema.json\\",\\n  \\"globalDependencies\\": [\\"**/.env.*local\\"],\\n  \\"pipeline\\": {\\n    \\"build\\": {\\n      \\"dependsOn\\": [\\"^build\\"],\\n      \\"outputs\\": [\\"dist/**\\", \\".next/**\\", \\"!.next/cache/**\\"]\\n    },\\n    \\"lint\\": {},\\n    \\"dev\\": {\\n      \\"cache\\": false,\\n      \\"persistent\\": true\\n    },\\n    \\"test\\": {\\n      \\"dependsOn\\": [\\"build\\"],\\n      \\"inputs\\": [\\"src/**/*.tsx\\", \\"src/**/*.ts\\", \\"test/**/*.ts\\", \\"test/**/*.tsx\\"]\\n    }\\n  }\\n}\\n</code></pre>\\n<h2>Core 패키지</h2>\\n<p>Core 패키지는 Modern Vector.js의 핵심 라이브러리를 포함합니다. 이 패키지는 플러그인 기반 아키텍처를 구현하고 벡터 그래픽 시스템의 기본 기능을 제공합니다.</p>\\n<h3>디렉토리 구조</h3>\\n<pre><code>packages/core/\\n├── src/                    # 소스 코드\\n│   ├── core/               # 코어 시스템\\n│   │   ├── engine.ts       # VectorEngine 구현\\n│   │   ├── services/       # 코어 서비스\\n│   │   │   ├── renderer.ts # RendererService\\n│   │   │   ├── events.ts   # EventService\\n│   │   │   └── scene.ts    # SceneService\\n│   │   └── types/          # 타입 정의\\n│   ├── plugins/            # 플러그인\\n│   │   ├── core/           # 코어 플러그인\\n│   │   └── renderers/      # 렌더러 플러그인\\n│   ├── performance/        # 성능 최적화\\n│   └── index.ts            # 진입점\\n├── dist/                   # 빌드 결과물\\n├── typedoc.json            # TypeDoc 설정\\n├── vite.config.ts          # Vite 설정\\n├── vitest.config.ts        # Vitest 설정\\n├── tsconfig.json           # TypeScript 설정\\n└── package.json            # 패키지 설정\\n</code></pre>\\n<h3>핵심 모듈</h3>\\n<h4>Core System</h4>\\n<p>Core System은 Modern Vector.js의 핵심 기능을 구현합니다:</p>\\n<ul>\\n<li><strong>VectorEngine</strong>: 플러그인 관리 및 핵심 서비스 제공</li>\\n<li><strong>Services</strong>: 렌더링, 이벤트, 씬 관리 등의 핵심 서비스</li>\\n<li><strong>Types</strong>: 인터페이스, 타입, 열거형 등의 타입 정의</li>\\n</ul>\\n<h4>Plugins</h4>\\n<p>Plugins는 Modern Vector.js의 기능을 확장하는 플러그인을 구현합니다:</p>\\n<ul>\\n<li><strong>Core Plugins</strong>: Math, Shape, Transform 등의 기본 플러그인</li>\\n<li><strong>Renderer Plugins</strong>: Canvas, SVG, WebGL 등의 렌더러 플러그인</li>\\n</ul>\\n<h2>Docs Site 패키지</h2>\\n<p>Docs Site 패키지는 Modern Vector.js의 문서 사이트를 구현합니다. 이 패키지는 Next.js, Tailwind CSS, shadcn/ui를 사용하여 구축되었으며, TypeDoc으로 생성된 API 문서를 포함합니다.</p>\\n<h3>디렉토리 구조</h3>\\n<pre><code>packages/docs-site/\\n├── public/                 # 정적 파일\\n│   ├── api-docs/           # TypeDoc으로 생성된 API 문서\\n│   └── 404.html            # GitHub Pages SPA 라우팅을 위한 404 페이지\\n├── src/                    # 소스 코드\\n│   ├── app/                # Next.js 앱 라우터\\n│   │   ├── layout.tsx      # 레이아웃 컴포넌트\\n│   │   ├── page.tsx        # 홈페이지\\n│   │   ├── docs/           # 문서 페이지\\n│   │   ├── examples/       # 예제 페이지\\n│   │   └── api/            # API 문서 페이지\\n│   ├── components/         # 재사용 가능한 컴포넌트\\n│   │   ├── ui/             # UI 컴포넌트\\n│   │   ├── code-blocks/    # 코드 블록 컴포넌트\\n│   │   ├── navigation/     # 네비게이션 컴포넌트\\n│   │   └── github-pages-redirect.tsx  # GitHub Pages SPA 라우팅 지원\\n│   ├── lib/                # 유틸리티 함수\\n│   └── types/              # TypeScript 타입 정의\\n├── scripts/                # 스크립트\\n│   └── generate-docs.js    # API 문서 생성 스크립트\\n├── dist/                   # 빌드 결과물\\n├── next.config.js          # Next.js 설정\\n├── contentlayer.config.js  # ContentLayer 설정\\n├── tailwind.config.js      # Tailwind CSS 설정\\n├── tsconfig.json           # TypeScript 설정\\n└── package.json            # 패키지 설정\\n</code></pre>\\n<h3>주요 기능</h3>\\n<h4>문서 페이지</h4>\\n<p>문서 페이지는 Modern Vector.js의 사용법, API, 예제 등을 설명합니다:</p>\\n<ul>\\n<li><strong>Getting Started</strong>: 시작하기 가이드</li>\\n<li><strong>Core Concepts</strong>: 핵심 개념 설명</li>\\n<li><strong>API Reference</strong>: API 문서</li>\\n<li><strong>Examples</strong>: 예제 코드</li>\\n</ul>\\n<h4>예제 페이지</h4>\\n<p>예제 페이지는 Modern Vector.js의 다양한 기능을 보여주는 인터랙티브 예제를 제공합니다:</p>\\n<ul>\\n<li><strong>Basic Shapes</strong>: 기본 도형 그리기</li>\\n<li><strong>Transformations</strong>: 변환 적용하기</li>\\n<li><strong>Path Operations</strong>: 경로 연산</li>\\n<li><strong>Plugins</strong>: 플러그인 사용하기</li>\\n</ul>\\n<h4>API 문서</h4>\\n<p>API 문서는 TypeDoc을 사용하여 자동으로 생성된 API 레퍼런스를 제공합니다:</p>\\n<ul>\\n<li><strong>Classes</strong>: 클래스 문서</li>\\n<li><strong>Interfaces</strong>: 인터페이스 문서</li>\\n<li><strong>Types</strong>: 타입 문서</li>\\n<li><strong>Functions</strong>: 함수 문서</li>\\n</ul>\\n<h2>개발 워크플로우</h2>\\n<h3>로컬 개발</h3>\\n<p>로컬 개발을 위한 명령어:</p>\\n<pre><code class=\\"language-bash\\"># 모든 패키지 개발 서버 실행\\npnpm dev\\n\\n# 특정 패키지 개발 서버 실행\\npnpm --filter @modern-vector/core dev\\npnpm --filter docs-site dev\\n</code></pre>\\n<h3>빌드</h3>\\n<p>빌드를 위한 명령어:</p>\\n<pre><code class=\\"language-bash\\"># 모든 패키지 빌드\\npnpm build\\n\\n# 특정 패키지 빌드\\npnpm --filter @modern-vector/core build\\npnpm --filter docs-site build\\n</code></pre>\\n<h3>테스트</h3>\\n<p>테스트를 위한 명령어:</p>\\n<pre><code class=\\"language-bash\\"># 모든 패키지 테스트\\npnpm test\\n\\n# 특정 패키지 테스트\\npnpm --filter @modern-vector/core test\\n</code></pre>\\n<h3>린트</h3>\\n<p>린트를 위한 명령어:</p>\\n<pre><code class=\\"language-bash\\"># 모든 패키지 린트\\npnpm lint\\n\\n# 특정 패키지 린트\\npnpm --filter @modern-vector/core lint\\npnpm --filter docs-site lint\\n</code></pre>\\n<h2>배포</h2>\\n<h3>Core 패키지 배포</h3>\\n<p>Core 패키지는 npm에 배포됩니다:</p>\\n<pre><code class=\\"language-bash\\"># 버전 업데이트\\ncd packages/core\\npnpm version patch|minor|major\\n\\n# 배포\\npnpm publish\\n</code></pre>\\n<h3>Docs Site 배포</h3>\\n<p>Docs Site는 GitHub Pages에 배포됩니다:</p>\\n<pre><code class=\\"language-bash\\"># 수동 배포\\ncd packages/docs-site\\npnpm build\\npnpm deploy\\n</code></pre>\\n<p>또는 GitHub Actions를 통한 자동 배포:</p>\\n<ol>\\n<li><code>main</code> 브랜치에 변경사항 푸시</li>\\n<li>GitHub Actions 워크플로우 실행</li>\\n<li>GitHub Pages에 배포</li>\\n</ol>"},"_id":"docs/getting-started/project-structure.md","_raw":{"sourceFilePath":"docs/getting-started/project-structure.md","sourceFileName":"project-structure.md","sourceFileDir":"docs/getting-started","contentType":"markdown","flattenedPath":"docs/getting-started/project-structure"},"type":"Doc","slug":"getting-started/project-structure","url":"/docs/getting-started/project-structure"},{"title":"Plugin","description":"Modern Vector.js의 플러그인 인터페이스 및 관련 타입에 대한 API 문서","body":{"raw":"\\n# Plugin\\n\\n`Plugin` 인터페이스는 Modern Vector.js의 확장 시스템의 기반입니다. 모든 플러그인은 이 인터페이스를 구현해야 하며, 이를 통해 라이브러리의 기능을 확장하고 사용자 정의 기능을 추가할 수 있습니다.\\n\\n## 구문\\n\\n```typescript\\ninterface Plugin {\\n  readonly id: string;\\n  readonly version: string;\\n  readonly dependencies?: string[];\\n  \\n  install(engine: VectorEngine): void | Promise<void>;\\n  uninstall(engine: VectorEngine): void | Promise<void>;\\n}\\n```\\n\\n## 속성\\n\\n### `id: string`\\n\\n플러그인의 고유 식별자입니다. 이 값은 플러그인 등록 및 조회에 사용됩니다.\\n\\n### `version: string`\\n\\n플러그인의 버전 정보입니다. 일반적으로 Semantic Versioning(SemVer) 형식을 따릅니다.\\n\\n### `dependencies?: string[]` (선택사항)\\n\\n이 플러그인이 의존하는 다른 플러그인의 ID 목록입니다. 엔진은 이 플러그인을 설치하기 전에 모든 의존성이 이미 설치되어 있는지 확인합니다.\\n\\n## 메서드\\n\\n### `install(engine: VectorEngine): void | Promise<void>`\\n\\n플러그인을 엔진에 설치합니다. 이 메서드는 플러그인이 필요로 하는 모든 초기화 작업을 수행해야 합니다.\\n\\n- **매개변수**: `engine` - 플러그인이 설치될 VectorEngine 인스턴스\\n- **반환값**: void 또는 Promise&lt;void&gt; (비동기 초기화 지원)\\n\\n### `uninstall(engine: VectorEngine): void | Promise<void>`\\n\\n플러그인을 엔진에서 제거합니다. 이 메서드는 플러그인이 할당한 모든 리소스를 정리해야 합니다.\\n\\n- **매개변수**: `engine` - 플러그인이 제거될 VectorEngine 인스턴스\\n- **반환값**: void 또는 Promise&lt;void&gt; (비동기 정리 지원)\\n\\n## 관련 타입\\n\\n### PluginOptions\\n\\n```typescript\\ninterface PluginOptions {\\n  [key: string]: any;\\n}\\n```\\n\\n플러그인 생성자에 전달되는 옵션 객체의 기본 인터페이스입니다. 각 플러그인은 이 인터페이스를 확장하여 자체 옵션을 정의할 수 있습니다.\\n\\n### PluginConstructor\\n\\n```typescript\\ninterface PluginConstructor<T extends Plugin = Plugin, O extends PluginOptions = PluginOptions> {\\n  new (options?: O): T;\\n}\\n```\\n\\n플러그인 클래스의 생성자 타입입니다. 이 타입은 플러그인 팩토리 함수나 플러그인 등록 시스템에서 사용됩니다.\\n\\n## 예제\\n\\n### 기본 플러그인 구현\\n\\n```typescript\\nimport { Plugin, VectorEngine } from \'modern-vector\';\\n\\ninterface GridPluginOptions {\\n  size?: number;\\n  color?: string;\\n  visible?: boolean;\\n}\\n\\nclass GridPlugin implements Plugin {\\n  readonly id = \'grid\';\\n  readonly version = \'1.0.0\';\\n  readonly dependencies = [\'renderer\'];\\n  \\n  private size: number;\\n  private color: string;\\n  private visible: boolean;\\n  \\n  constructor(options: GridPluginOptions = {}) {\\n    this.size = options.size || 20;\\n    this.color = options.color || \'#cccccc\';\\n    this.visible = options.visible !== undefined ? options.visible : true;\\n  }\\n  \\n  install(engine: VectorEngine): void {\\n    // 렌더러 플러그인 가져오기\\n    const renderer = engine.getPlugin(\'renderer\');\\n    if (!renderer) {\\n      throw new Error(\'Renderer plugin is required\');\\n    }\\n    \\n    // 그리드 렌더링 이벤트 리스너 등록\\n    engine.on(\'beforeRender\', this.renderGrid.bind(this));\\n    \\n    // 그리드 관련 서비스 등록\\n    engine.registerService(\'grid\', {\\n      setSize: (size: number) => { this.size = size; },\\n      setColor: (color: string) => { this.color = color; },\\n      setVisible: (visible: boolean) => { this.visible = visible; },\\n      getSize: () => this.size,\\n      getColor: () => this.color,\\n      isVisible: () => this.visible\\n    });\\n    \\n    console.log(`GridPlugin ${this.version} installed`);\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 이벤트 리스너 제거\\n    engine.off(\'beforeRender\', this.renderGrid.bind(this));\\n    \\n    console.log(`GridPlugin ${this.version} uninstalled`);\\n  }\\n  \\n  private renderGrid(): void {\\n    if (!this.visible) return;\\n    \\n    // 그리드 렌더링 로직\\n    // ...\\n  }\\n}\\n```\\n\\n### 비동기 플러그인 구현\\n\\n```typescript\\nimport { Plugin, VectorEngine } from \'modern-vector\';\\n\\nclass AssetLoaderPlugin implements Plugin {\\n  readonly id = \'asset-loader\';\\n  readonly version = \'1.0.0\';\\n  \\n  private assets: Map<string, any> = new Map();\\n  \\n  async install(engine: VectorEngine): Promise<void> {\\n    // 에셋 비동기 로드\\n    await this.loadAssets();\\n    \\n    // 에셋 서비스 등록\\n    engine.registerService(\'assets\', {\\n      getAsset: (id: string) => this.assets.get(id),\\n      hasAsset: (id: string) => this.assets.has(id)\\n    });\\n    \\n    console.log(\'AssetLoaderPlugin installed\');\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 리소스 정리\\n    this.assets.clear();\\n    console.log(\'AssetLoaderPlugin uninstalled\');\\n  }\\n  \\n  private async loadAssets(): Promise<void> {\\n    // 에셋 로딩 로직\\n    return new Promise(resolve => {\\n      setTimeout(() => {\\n        this.assets.set(\'image1\', { /* 이미지 데이터 */ });\\n        this.assets.set(\'image2\', { /* 이미지 데이터 */ });\\n        resolve();\\n      }, 1000);\\n    });\\n  }\\n}\\n```\\n\\n## 플러그인 사용 예제\\n\\n```typescript\\nimport { VectorEngine } from \'modern-vector\';\\nimport { GridPlugin } from \'./plugins/grid-plugin\';\\n\\nconst engine = new VectorEngine();\\n\\n// 플러그인 등록\\nengine.use(new GridPlugin({ size: 30, color: \'#dddddd\' }));\\n\\n// 플러그인 서비스 사용\\nconst gridService = engine.getService(\'grid\');\\ngridService.setSize(50);\\ngridService.setVisible(true);\\n\\n// 플러그인 제거\\nengine.remove(\'grid\');\\n```\\n\\n## 모범 사례\\n\\n1. **고유한 ID 사용**: 플러그인 ID는 고유해야 하며, 가능하면 네임스페이스를 사용하세요 (예: `@company/feature`).\\n2. **의존성 명시**: 플러그인이 다른 플러그인에 의존하는 경우, `dependencies` 배열에 명시적으로 선언하세요.\\n3. **적절한 리소스 정리**: `uninstall` 메서드에서 모든 리소스(이벤트 리스너, 타이머 등)를 정리하세요.\\n4. **옵션 기본값 제공**: 생성자에서 모든 옵션에 대한 기본값을 제공하여 사용자가 모든 옵션을 지정할 필요가 없도록 하세요.\\n5. **서비스 등록**: 플러그인의 기능을 외부에 노출하려면 서비스를 등록하세요.\\n\\n## 관련 API\\n\\n- [VectorEngine](/docs/api-reference/core/vector-engine) - 플러그인이 설치되는 핵심 엔진\\n- [Service](/docs/api-reference/core/service) - 서비스 시스템 ","html":"<h1>Plugin</h1>\\n<p><code>Plugin</code> 인터페이스는 Modern Vector.js의 확장 시스템의 기반입니다. 모든 플러그인은 이 인터페이스를 구현해야 하며, 이를 통해 라이브러리의 기능을 확장하고 사용자 정의 기능을 추가할 수 있습니다.</p>\\n<h2>구문</h2>\\n<pre><code class=\\"language-typescript\\">interface Plugin {\\n  readonly id: string;\\n  readonly version: string;\\n  readonly dependencies?: string[];\\n  \\n  install(engine: VectorEngine): void | Promise&#x3C;void>;\\n  uninstall(engine: VectorEngine): void | Promise&#x3C;void>;\\n}\\n</code></pre>\\n<h2>속성</h2>\\n<h3><code>id: string</code></h3>\\n<p>플러그인의 고유 식별자입니다. 이 값은 플러그인 등록 및 조회에 사용됩니다.</p>\\n<h3><code>version: string</code></h3>\\n<p>플러그인의 버전 정보입니다. 일반적으로 Semantic Versioning(SemVer) 형식을 따릅니다.</p>\\n<h3><code>dependencies?: string[]</code> (선택사항)</h3>\\n<p>이 플러그인이 의존하는 다른 플러그인의 ID 목록입니다. 엔진은 이 플러그인을 설치하기 전에 모든 의존성이 이미 설치되어 있는지 확인합니다.</p>\\n<h2>메서드</h2>\\n<h3><code>install(engine: VectorEngine): void | Promise&#x3C;void></code></h3>\\n<p>플러그인을 엔진에 설치합니다. 이 메서드는 플러그인이 필요로 하는 모든 초기화 작업을 수행해야 합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>engine</code> - 플러그인이 설치될 VectorEngine 인스턴스</li>\\n<li><strong>반환값</strong>: void 또는 Promise&#x3C;void> (비동기 초기화 지원)</li>\\n</ul>\\n<h3><code>uninstall(engine: VectorEngine): void | Promise&#x3C;void></code></h3>\\n<p>플러그인을 엔진에서 제거합니다. 이 메서드는 플러그인이 할당한 모든 리소스를 정리해야 합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>engine</code> - 플러그인이 제거될 VectorEngine 인스턴스</li>\\n<li><strong>반환값</strong>: void 또는 Promise&#x3C;void> (비동기 정리 지원)</li>\\n</ul>\\n<h2>관련 타입</h2>\\n<h3>PluginOptions</h3>\\n<pre><code class=\\"language-typescript\\">interface PluginOptions {\\n  [key: string]: any;\\n}\\n</code></pre>\\n<p>플러그인 생성자에 전달되는 옵션 객체의 기본 인터페이스입니다. 각 플러그인은 이 인터페이스를 확장하여 자체 옵션을 정의할 수 있습니다.</p>\\n<h3>PluginConstructor</h3>\\n<pre><code class=\\"language-typescript\\">interface PluginConstructor&#x3C;T extends Plugin = Plugin, O extends PluginOptions = PluginOptions> {\\n  new (options?: O): T;\\n}\\n</code></pre>\\n<p>플러그인 클래스의 생성자 타입입니다. 이 타입은 플러그인 팩토리 함수나 플러그인 등록 시스템에서 사용됩니다.</p>\\n<h2>예제</h2>\\n<h3>기본 플러그인 구현</h3>\\n<pre><code class=\\"language-typescript\\">import { Plugin, VectorEngine } from \'modern-vector\';\\n\\ninterface GridPluginOptions {\\n  size?: number;\\n  color?: string;\\n  visible?: boolean;\\n}\\n\\nclass GridPlugin implements Plugin {\\n  readonly id = \'grid\';\\n  readonly version = \'1.0.0\';\\n  readonly dependencies = [\'renderer\'];\\n  \\n  private size: number;\\n  private color: string;\\n  private visible: boolean;\\n  \\n  constructor(options: GridPluginOptions = {}) {\\n    this.size = options.size || 20;\\n    this.color = options.color || \'#cccccc\';\\n    this.visible = options.visible !== undefined ? options.visible : true;\\n  }\\n  \\n  install(engine: VectorEngine): void {\\n    // 렌더러 플러그인 가져오기\\n    const renderer = engine.getPlugin(\'renderer\');\\n    if (!renderer) {\\n      throw new Error(\'Renderer plugin is required\');\\n    }\\n    \\n    // 그리드 렌더링 이벤트 리스너 등록\\n    engine.on(\'beforeRender\', this.renderGrid.bind(this));\\n    \\n    // 그리드 관련 서비스 등록\\n    engine.registerService(\'grid\', {\\n      setSize: (size: number) => { this.size = size; },\\n      setColor: (color: string) => { this.color = color; },\\n      setVisible: (visible: boolean) => { this.visible = visible; },\\n      getSize: () => this.size,\\n      getColor: () => this.color,\\n      isVisible: () => this.visible\\n    });\\n    \\n    console.log(`GridPlugin ${this.version} installed`);\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 이벤트 리스너 제거\\n    engine.off(\'beforeRender\', this.renderGrid.bind(this));\\n    \\n    console.log(`GridPlugin ${this.version} uninstalled`);\\n  }\\n  \\n  private renderGrid(): void {\\n    if (!this.visible) return;\\n    \\n    // 그리드 렌더링 로직\\n    // ...\\n  }\\n}\\n</code></pre>\\n<h3>비동기 플러그인 구현</h3>\\n<pre><code class=\\"language-typescript\\">import { Plugin, VectorEngine } from \'modern-vector\';\\n\\nclass AssetLoaderPlugin implements Plugin {\\n  readonly id = \'asset-loader\';\\n  readonly version = \'1.0.0\';\\n  \\n  private assets: Map&#x3C;string, any> = new Map();\\n  \\n  async install(engine: VectorEngine): Promise&#x3C;void> {\\n    // 에셋 비동기 로드\\n    await this.loadAssets();\\n    \\n    // 에셋 서비스 등록\\n    engine.registerService(\'assets\', {\\n      getAsset: (id: string) => this.assets.get(id),\\n      hasAsset: (id: string) => this.assets.has(id)\\n    });\\n    \\n    console.log(\'AssetLoaderPlugin installed\');\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 리소스 정리\\n    this.assets.clear();\\n    console.log(\'AssetLoaderPlugin uninstalled\');\\n  }\\n  \\n  private async loadAssets(): Promise&#x3C;void> {\\n    // 에셋 로딩 로직\\n    return new Promise(resolve => {\\n      setTimeout(() => {\\n        this.assets.set(\'image1\', { /* 이미지 데이터 */ });\\n        this.assets.set(\'image2\', { /* 이미지 데이터 */ });\\n        resolve();\\n      }, 1000);\\n    });\\n  }\\n}\\n</code></pre>\\n<h2>플러그인 사용 예제</h2>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine } from \'modern-vector\';\\nimport { GridPlugin } from \'./plugins/grid-plugin\';\\n\\nconst engine = new VectorEngine();\\n\\n// 플러그인 등록\\nengine.use(new GridPlugin({ size: 30, color: \'#dddddd\' }));\\n\\n// 플러그인 서비스 사용\\nconst gridService = engine.getService(\'grid\');\\ngridService.setSize(50);\\ngridService.setVisible(true);\\n\\n// 플러그인 제거\\nengine.remove(\'grid\');\\n</code></pre>\\n<h2>모범 사례</h2>\\n<ol>\\n<li><strong>고유한 ID 사용</strong>: 플러그인 ID는 고유해야 하며, 가능하면 네임스페이스를 사용하세요 (예: <code>@company/feature</code>).</li>\\n<li><strong>의존성 명시</strong>: 플러그인이 다른 플러그인에 의존하는 경우, <code>dependencies</code> 배열에 명시적으로 선언하세요.</li>\\n<li><strong>적절한 리소스 정리</strong>: <code>uninstall</code> 메서드에서 모든 리소스(이벤트 리스너, 타이머 등)를 정리하세요.</li>\\n<li><strong>옵션 기본값 제공</strong>: 생성자에서 모든 옵션에 대한 기본값을 제공하여 사용자가 모든 옵션을 지정할 필요가 없도록 하세요.</li>\\n<li><strong>서비스 등록</strong>: 플러그인의 기능을 외부에 노출하려면 서비스를 등록하세요.</li>\\n</ol>\\n<h2>관련 API</h2>\\n<ul>\\n<li><a href=\\"/docs/api-reference/core/vector-engine\\">VectorEngine</a> - 플러그인이 설치되는 핵심 엔진</li>\\n<li><a href=\\"/docs/api-reference/core/service\\">Service</a> - 서비스 시스템</li>\\n</ul>"},"_id":"docs/api-reference/core/plugin.md","_raw":{"sourceFilePath":"docs/api-reference/core/plugin.md","sourceFileName":"plugin.md","sourceFileDir":"docs/api-reference/core","contentType":"markdown","flattenedPath":"docs/api-reference/core/plugin"},"type":"Doc","slug":"api-reference/core/plugin","url":"/docs/api-reference/core/plugin"},{"title":"Service","description":"Modern Vector.js의 서비스 시스템에 대한 API 문서","body":{"raw":"\\n# Service 시스템\\n\\nModern Vector.js의 서비스 시스템은 플러그인 간 통신과 기능 공유를 위한 메커니즘을 제공합니다. 서비스는 특정 기능이나 리소스에 대한 접근을 제공하는 객체로, 플러그인이나 애플리케이션 코드에서 사용할 수 있습니다.\\n\\n## 개요\\n\\n서비스 시스템은 다음과 같은 주요 기능을 제공합니다:\\n\\n1. **플러그인 간 통신**: 플러그인은 서비스를 통해 다른 플러그인과 통신할 수 있습니다.\\n2. **기능 공유**: 플러그인은 자신의 기능을 서비스로 노출하여 다른 플러그인이나 애플리케이션 코드에서 사용할 수 있게 합니다.\\n3. **의존성 관리**: 서비스는 플러그인 간의 직접적인 의존성을 줄이는 데 도움이 됩니다.\\n\\n## 서비스 등록 및 사용\\n\\n### 서비스 등록\\n\\n```typescript\\n// VectorEngine 인스턴스에 서비스 등록\\nengine.registerService<T>(serviceId: string, service: T): VectorEngine\\n```\\n\\n#### 매개변수\\n\\n- `serviceId`: 서비스의 고유 식별자\\n- `service`: 등록할 서비스 객체\\n\\n#### 반환값\\n\\n메서드 체이닝을 위한 VectorEngine 인스턴스\\n\\n### 서비스 조회\\n\\n```typescript\\n// 서비스 조회\\nengine.getService<T>(serviceId: string): T | undefined\\n```\\n\\n#### 매개변수\\n\\n- `serviceId`: 조회할 서비스의 식별자\\n\\n#### 반환값\\n\\n서비스 객체 또는 서비스가 없는 경우 undefined\\n\\n## 서비스 인터페이스\\n\\n서비스는 특별한 인터페이스를 구현할 필요가 없습니다. 어떤 객체든 서비스로 등록할 수 있습니다. 그러나 일관성을 위해 서비스 인터페이스를 정의하는 것이 좋습니다.\\n\\n```typescript\\n// 로거 서비스 인터페이스 예시\\ninterface LoggerService {\\n  log(message: string, level?: LogLevel): void;\\n  error(message: string, error?: Error): void;\\n  warn(message: string): void;\\n  info(message: string): void;\\n  debug(message: string): void;\\n}\\n\\n// 렌더링 서비스 인터페이스 예시\\ninterface RenderService {\\n  render(scene: Scene): void;\\n  clear(): void;\\n  resize(width: number, height: number): void;\\n  getContext(): RenderContext;\\n}\\n```\\n\\n## 예제\\n\\n### 서비스 등록 예제\\n\\n```typescript\\nimport { Plugin, VectorEngine } from \'modern-vector\';\\n\\n// 로거 서비스 인터페이스\\ninterface LoggerService {\\n  log(message: string, level?: string): void;\\n  error(message: string, error?: Error): void;\\n  warn(message: string): void;\\n  info(message: string): void;\\n  debug(message: string): void;\\n}\\n\\n// 로거 플러그인 구현\\nclass LoggerPlugin implements Plugin {\\n  readonly id = \'logger\';\\n  readonly version = \'1.0.0\';\\n  \\n  install(engine: VectorEngine): void {\\n    // 로거 서비스 구현\\n    const loggerService: LoggerService = {\\n      log: (message, level = \'info\') => {\\n        console.log(`[${level.toUpperCase()}] ${message}`);\\n      },\\n      error: (message, error) => {\\n        console.error(`[ERROR] ${message}`, error);\\n      },\\n      warn: (message) => {\\n        console.warn(`[WARN] ${message}`);\\n      },\\n      info: (message) => {\\n        console.info(`[INFO] ${message}`);\\n      },\\n      debug: (message) => {\\n        console.debug(`[DEBUG] ${message}`);\\n      }\\n    };\\n    \\n    // 서비스 등록\\n    engine.registerService<LoggerService>(\'logger\', loggerService);\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 정리 작업 (필요한 경우)\\n  }\\n}\\n```\\n\\n### 서비스 사용 예제\\n\\n```typescript\\nimport { Plugin, VectorEngine } from \'modern-vector\';\\n\\n// 다른 플러그인에서 로거 서비스 사용\\nclass ShapePlugin implements Plugin {\\n  readonly id = \'shape\';\\n  readonly version = \'1.0.0\';\\n  readonly dependencies = [\'logger\']; // 로거 플러그인에 의존\\n  \\n  install(engine: VectorEngine): void {\\n    // 로거 서비스 가져오기\\n    const logger = engine.getService<LoggerService>(\'logger\');\\n    \\n    if (!logger) {\\n      throw new Error(\'Logger service is required\');\\n    }\\n    \\n    // 로거 서비스 사용\\n    logger.info(\'ShapePlugin installed\');\\n    \\n    // 도형 관련 서비스 등록\\n    engine.registerService(\'shape\', {\\n      createRectangle: (x, y, width, height) => {\\n        logger.debug(`Creating rectangle at (${x}, ${y}) with size ${width}x${height}`);\\n        // 사각형 생성 로직\\n        return { type: \'rectangle\', x, y, width, height };\\n      },\\n      createCircle: (x, y, radius) => {\\n        logger.debug(`Creating circle at (${x}, ${y}) with radius ${radius}`);\\n        // 원 생성 로직\\n        return { type: \'circle\', x, y, radius };\\n      }\\n    });\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    const logger = engine.getService<LoggerService>(\'logger\');\\n    if (logger) {\\n      logger.info(\'ShapePlugin uninstalled\');\\n    }\\n  }\\n}\\n```\\n\\n### 애플리케이션 코드에서 서비스 사용\\n\\n```typescript\\nimport { VectorEngine } from \'modern-vector\';\\nimport { LoggerPlugin } from \'./plugins/logger-plugin\';\\nimport { ShapePlugin } from \'./plugins/shape-plugin\';\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// 플러그인 등록\\nengine.use(new LoggerPlugin())\\n      .use(new ShapePlugin());\\n\\n// 서비스 사용\\nconst logger = engine.getService<LoggerService>(\'logger\');\\nconst shapeService = engine.getService(\'shape\');\\n\\nif (logger && shapeService) {\\n  logger.info(\'Creating shapes\');\\n  \\n  // 도형 생성\\n  const rectangle = shapeService.createRectangle(10, 10, 100, 50);\\n  const circle = shapeService.createCircle(150, 150, 30);\\n  \\n  logger.info(\'Shapes created\');\\n}\\n```\\n\\n## 모범 사례\\n\\n1. **명확한 서비스 인터페이스 정의**: 서비스의 인터페이스를 명확하게 정의하여 사용자가 서비스의 기능을 쉽게 이해할 수 있도록 합니다.\\n\\n2. **서비스 ID 네이밍 규칙**: 서비스 ID는 고유하고 의미 있는 이름을 사용하세요. 가능하면 네임스페이스를 사용하여 충돌을 방지하세요 (예: `@company/feature`).\\n\\n3. **서비스 의존성 처리**: 서비스가 다른 서비스에 의존하는 경우, 해당 서비스가 존재하는지 확인하고 적절하게 처리하세요.\\n\\n4. **타입 안전성 유지**: TypeScript의 제네릭을 활용하여 서비스 등록 및 조회 시 타입 안전성을 유지하세요.\\n\\n5. **서비스 생명주기 관리**: 플러그인이 제거될 때 해당 플러그인이 등록한 서비스도 정리되어야 합니다.\\n\\n## 관련 API\\n\\n- [VectorEngine](/docs/api-reference/core/vector-engine) - 서비스 등록 및 조회 메서드를 제공하는 핵심 엔진\\n- [Plugin](/docs/api-reference/core/plugin) - 서비스를 등록하고 사용하는 플러그인 인터페이스 ","html":"<h1>Service 시스템</h1>\\n<p>Modern Vector.js의 서비스 시스템은 플러그인 간 통신과 기능 공유를 위한 메커니즘을 제공합니다. 서비스는 특정 기능이나 리소스에 대한 접근을 제공하는 객체로, 플러그인이나 애플리케이션 코드에서 사용할 수 있습니다.</p>\\n<h2>개요</h2>\\n<p>서비스 시스템은 다음과 같은 주요 기능을 제공합니다:</p>\\n<ol>\\n<li><strong>플러그인 간 통신</strong>: 플러그인은 서비스를 통해 다른 플러그인과 통신할 수 있습니다.</li>\\n<li><strong>기능 공유</strong>: 플러그인은 자신의 기능을 서비스로 노출하여 다른 플러그인이나 애플리케이션 코드에서 사용할 수 있게 합니다.</li>\\n<li><strong>의존성 관리</strong>: 서비스는 플러그인 간의 직접적인 의존성을 줄이는 데 도움이 됩니다.</li>\\n</ol>\\n<h2>서비스 등록 및 사용</h2>\\n<h3>서비스 등록</h3>\\n<pre><code class=\\"language-typescript\\">// VectorEngine 인스턴스에 서비스 등록\\nengine.registerService&#x3C;T>(serviceId: string, service: T): VectorEngine\\n</code></pre>\\n<h4>매개변수</h4>\\n<ul>\\n<li><code>serviceId</code>: 서비스의 고유 식별자</li>\\n<li><code>service</code>: 등록할 서비스 객체</li>\\n</ul>\\n<h4>반환값</h4>\\n<p>메서드 체이닝을 위한 VectorEngine 인스턴스</p>\\n<h3>서비스 조회</h3>\\n<pre><code class=\\"language-typescript\\">// 서비스 조회\\nengine.getService&#x3C;T>(serviceId: string): T | undefined\\n</code></pre>\\n<h4>매개변수</h4>\\n<ul>\\n<li><code>serviceId</code>: 조회할 서비스의 식별자</li>\\n</ul>\\n<h4>반환값</h4>\\n<p>서비스 객체 또는 서비스가 없는 경우 undefined</p>\\n<h2>서비스 인터페이스</h2>\\n<p>서비스는 특별한 인터페이스를 구현할 필요가 없습니다. 어떤 객체든 서비스로 등록할 수 있습니다. 그러나 일관성을 위해 서비스 인터페이스를 정의하는 것이 좋습니다.</p>\\n<pre><code class=\\"language-typescript\\">// 로거 서비스 인터페이스 예시\\ninterface LoggerService {\\n  log(message: string, level?: LogLevel): void;\\n  error(message: string, error?: Error): void;\\n  warn(message: string): void;\\n  info(message: string): void;\\n  debug(message: string): void;\\n}\\n\\n// 렌더링 서비스 인터페이스 예시\\ninterface RenderService {\\n  render(scene: Scene): void;\\n  clear(): void;\\n  resize(width: number, height: number): void;\\n  getContext(): RenderContext;\\n}\\n</code></pre>\\n<h2>예제</h2>\\n<h3>서비스 등록 예제</h3>\\n<pre><code class=\\"language-typescript\\">import { Plugin, VectorEngine } from \'modern-vector\';\\n\\n// 로거 서비스 인터페이스\\ninterface LoggerService {\\n  log(message: string, level?: string): void;\\n  error(message: string, error?: Error): void;\\n  warn(message: string): void;\\n  info(message: string): void;\\n  debug(message: string): void;\\n}\\n\\n// 로거 플러그인 구현\\nclass LoggerPlugin implements Plugin {\\n  readonly id = \'logger\';\\n  readonly version = \'1.0.0\';\\n  \\n  install(engine: VectorEngine): void {\\n    // 로거 서비스 구현\\n    const loggerService: LoggerService = {\\n      log: (message, level = \'info\') => {\\n        console.log(`[${level.toUpperCase()}] ${message}`);\\n      },\\n      error: (message, error) => {\\n        console.error(`[ERROR] ${message}`, error);\\n      },\\n      warn: (message) => {\\n        console.warn(`[WARN] ${message}`);\\n      },\\n      info: (message) => {\\n        console.info(`[INFO] ${message}`);\\n      },\\n      debug: (message) => {\\n        console.debug(`[DEBUG] ${message}`);\\n      }\\n    };\\n    \\n    // 서비스 등록\\n    engine.registerService&#x3C;LoggerService>(\'logger\', loggerService);\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    // 정리 작업 (필요한 경우)\\n  }\\n}\\n</code></pre>\\n<h3>서비스 사용 예제</h3>\\n<pre><code class=\\"language-typescript\\">import { Plugin, VectorEngine } from \'modern-vector\';\\n\\n// 다른 플러그인에서 로거 서비스 사용\\nclass ShapePlugin implements Plugin {\\n  readonly id = \'shape\';\\n  readonly version = \'1.0.0\';\\n  readonly dependencies = [\'logger\']; // 로거 플러그인에 의존\\n  \\n  install(engine: VectorEngine): void {\\n    // 로거 서비스 가져오기\\n    const logger = engine.getService&#x3C;LoggerService>(\'logger\');\\n    \\n    if (!logger) {\\n      throw new Error(\'Logger service is required\');\\n    }\\n    \\n    // 로거 서비스 사용\\n    logger.info(\'ShapePlugin installed\');\\n    \\n    // 도형 관련 서비스 등록\\n    engine.registerService(\'shape\', {\\n      createRectangle: (x, y, width, height) => {\\n        logger.debug(`Creating rectangle at (${x}, ${y}) with size ${width}x${height}`);\\n        // 사각형 생성 로직\\n        return { type: \'rectangle\', x, y, width, height };\\n      },\\n      createCircle: (x, y, radius) => {\\n        logger.debug(`Creating circle at (${x}, ${y}) with radius ${radius}`);\\n        // 원 생성 로직\\n        return { type: \'circle\', x, y, radius };\\n      }\\n    });\\n  }\\n  \\n  uninstall(engine: VectorEngine): void {\\n    const logger = engine.getService&#x3C;LoggerService>(\'logger\');\\n    if (logger) {\\n      logger.info(\'ShapePlugin uninstalled\');\\n    }\\n  }\\n}\\n</code></pre>\\n<h3>애플리케이션 코드에서 서비스 사용</h3>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine } from \'modern-vector\';\\nimport { LoggerPlugin } from \'./plugins/logger-plugin\';\\nimport { ShapePlugin } from \'./plugins/shape-plugin\';\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// 플러그인 등록\\nengine.use(new LoggerPlugin())\\n      .use(new ShapePlugin());\\n\\n// 서비스 사용\\nconst logger = engine.getService&#x3C;LoggerService>(\'logger\');\\nconst shapeService = engine.getService(\'shape\');\\n\\nif (logger &#x26;&#x26; shapeService) {\\n  logger.info(\'Creating shapes\');\\n  \\n  // 도형 생성\\n  const rectangle = shapeService.createRectangle(10, 10, 100, 50);\\n  const circle = shapeService.createCircle(150, 150, 30);\\n  \\n  logger.info(\'Shapes created\');\\n}\\n</code></pre>\\n<h2>모범 사례</h2>\\n<ol>\\n<li>\\n<p><strong>명확한 서비스 인터페이스 정의</strong>: 서비스의 인터페이스를 명확하게 정의하여 사용자가 서비스의 기능을 쉽게 이해할 수 있도록 합니다.</p>\\n</li>\\n<li>\\n<p><strong>서비스 ID 네이밍 규칙</strong>: 서비스 ID는 고유하고 의미 있는 이름을 사용하세요. 가능하면 네임스페이스를 사용하여 충돌을 방지하세요 (예: <code>@company/feature</code>).</p>\\n</li>\\n<li>\\n<p><strong>서비스 의존성 처리</strong>: 서비스가 다른 서비스에 의존하는 경우, 해당 서비스가 존재하는지 확인하고 적절하게 처리하세요.</p>\\n</li>\\n<li>\\n<p><strong>타입 안전성 유지</strong>: TypeScript의 제네릭을 활용하여 서비스 등록 및 조회 시 타입 안전성을 유지하세요.</p>\\n</li>\\n<li>\\n<p><strong>서비스 생명주기 관리</strong>: 플러그인이 제거될 때 해당 플러그인이 등록한 서비스도 정리되어야 합니다.</p>\\n</li>\\n</ol>\\n<h2>관련 API</h2>\\n<ul>\\n<li><a href=\\"/docs/api-reference/core/vector-engine\\">VectorEngine</a> - 서비스 등록 및 조회 메서드를 제공하는 핵심 엔진</li>\\n<li><a href=\\"/docs/api-reference/core/plugin\\">Plugin</a> - 서비스를 등록하고 사용하는 플러그인 인터페이스</li>\\n</ul>"},"_id":"docs/api-reference/core/service.md","_raw":{"sourceFilePath":"docs/api-reference/core/service.md","sourceFileName":"service.md","sourceFileDir":"docs/api-reference/core","contentType":"markdown","flattenedPath":"docs/api-reference/core/service"},"type":"Doc","slug":"api-reference/core/service","url":"/docs/api-reference/core/service"},{"title":"VectorEngine","description":"Modern Vector.js의 핵심 엔진 클래스에 대한 API 문서","body":{"raw":"\\n# VectorEngine\\n\\n`VectorEngine`은 Modern Vector.js의 핵심 클래스로, 벡터 그래픽 시스템의 중앙 제어 지점 역할을 합니다. 이 클래스는 플러그인 관리, 서비스 제공, 렌더링 조정 등 라이브러리의 모든 주요 기능을 관리합니다.\\n\\n## 구문\\n\\n```typescript\\nclass VectorEngine {\\n  constructor(options?: VectorEngineOptions);\\n  \\n  // 플러그인 관리\\n  use<T extends Plugin>(plugin: T): this;\\n  remove(pluginId: string): boolean;\\n  getPlugin<T extends Plugin>(id: string): T | undefined;\\n  hasPlugin(id: string): boolean;\\n  \\n  // 서비스 관리\\n  registerService<T>(serviceId: string, service: T): this;\\n  getService<T>(serviceId: string): T | undefined;\\n  \\n  // 렌더링 및 업데이트\\n  render(): void;\\n  update(deltaTime: number): void;\\n  \\n  // 이벤트 관리\\n  on<K extends keyof EngineEvents>(event: K, listener: EngineEventListener<K>): this;\\n  off<K extends keyof EngineEvents>(event: K, listener: EngineEventListener<K>): this;\\n  emit<K extends keyof EngineEvents>(event: K, ...args: Parameters<EngineEventListener<K>>): boolean;\\n  \\n  // 리소스 관리\\n  dispose(): void;\\n}\\n```\\n\\n## 생성자\\n\\n### `constructor(options?: VectorEngineOptions)`\\n\\nVectorEngine 인스턴스를 생성합니다.\\n\\n#### 매개변수\\n\\n- `options` (선택사항): 엔진 초기화 옵션\\n  - `autoRender` (boolean): 자동 렌더링 활성화 여부 (기본값: `true`)\\n  - `plugins` (Plugin[]): 초기화 시 등록할 플러그인 배열\\n  - `services` (Record&lt;string, any&gt;): 초기화 시 등록할 서비스 객체\\n\\n## 메서드\\n\\n### 플러그인 관리\\n\\n#### `use<T extends Plugin>(plugin: T): this`\\n\\n플러그인을 엔진에 등록합니다.\\n\\n- **매개변수**: `plugin` - 등록할 플러그인 인스턴스\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `remove(pluginId: string): boolean`\\n\\nID로 플러그인을 제거합니다.\\n\\n- **매개변수**: `pluginId` - 제거할 플러그인의 ID\\n- **반환값**: 제거 성공 여부\\n\\n#### `getPlugin<T extends Plugin>(id: string): T | undefined`\\n\\nID로 플러그인을 조회합니다.\\n\\n- **매개변수**: `id` - 조회할 플러그인의 ID\\n- **반환값**: 플러그인 인스턴스 또는 undefined\\n\\n#### `hasPlugin(id: string): boolean`\\n\\n특정 ID의 플러그인이 등록되어 있는지 확인합니다.\\n\\n- **매개변수**: `id` - 확인할 플러그인의 ID\\n- **반환값**: 플러그인 존재 여부\\n\\n### 서비스 관리\\n\\n#### `registerService<T>(serviceId: string, service: T): this`\\n\\n서비스를 엔진에 등록합니다.\\n\\n- **매개변수**: \\n  - `serviceId` - 서비스 식별자\\n  - `service` - 서비스 인스턴스\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `getService<T>(serviceId: string): T | undefined`\\n\\nID로 서비스를 조회합니다.\\n\\n- **매개변수**: `serviceId` - 조회할 서비스의 ID\\n- **반환값**: 서비스 인스턴스 또는 undefined\\n\\n### 렌더링 및 업데이트\\n\\n#### `render(): void`\\n\\n현재 장면을 렌더링합니다. 등록된 렌더러 플러그인을 통해 실행됩니다.\\n\\n#### `update(deltaTime: number): void`\\n\\n엔진 상태를 업데이트합니다.\\n\\n- **매개변수**: `deltaTime` - 이전 프레임과의 시간 차이(밀리초)\\n\\n### 이벤트 관리\\n\\n#### `on<K extends keyof EngineEvents>(event: K, listener: EngineEventListener<K>): this`\\n\\n이벤트 리스너를 등록합니다.\\n\\n- **매개변수**: \\n  - `event` - 이벤트 이름\\n  - `listener` - 이벤트 핸들러 함수\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `off<K extends keyof EngineEvents>(event: K, listener: EngineEventListener<K>): this`\\n\\n이벤트 리스너를 제거합니다.\\n\\n- **매개변수**: \\n  - `event` - 이벤트 이름\\n  - `listener` - 제거할 이벤트 핸들러 함수\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `emit<K extends keyof EngineEvents>(event: K, ...args: Parameters<EngineEventListener<K>>): boolean`\\n\\n이벤트를 발생시킵니다.\\n\\n- **매개변수**: \\n  - `event` - 발생시킬 이벤트 이름\\n  - `args` - 이벤트 핸들러에 전달할 인자들\\n- **반환값**: 이벤트가 처리되었는지 여부\\n\\n### 리소스 관리\\n\\n#### `dispose(): void`\\n\\n엔진과 관련된 모든 리소스를 정리합니다. 등록된 모든 플러그인의 `uninstall` 메서드를 호출합니다.\\n\\n## 예제\\n\\n### 기본 사용법\\n\\n```typescript\\nimport { VectorEngine } from \'modern-vector\';\\nimport { CanvasRendererPlugin } from \'modern-vector/plugins/canvas-renderer\';\\nimport { ShapePlugin } from \'modern-vector/plugins/shape\';\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// 플러그인 등록\\nengine.use(new CanvasRendererPlugin({ canvas: document.getElementById(\'canvas\') }))\\n      .use(new ShapePlugin());\\n\\n// 서비스 등록\\nengine.registerService(\'logger\', {\\n  log: (message: string) => console.log(`[Vector]: ${message}`)\\n});\\n\\n// 이벤트 리스너 등록\\nengine.on(\'render\', () => {\\n  console.log(\'Scene rendered\');\\n});\\n\\n// 렌더링 실행\\nengine.render();\\n\\n// 리소스 정리\\n// engine.dispose();\\n```\\n\\n### 플러그인 관리\\n\\n```typescript\\n// 플러그인 등록\\nengine.use(new ShapePlugin());\\n\\n// 플러그인 조회\\nconst shapePlugin = engine.getPlugin<ShapePlugin>(\'shape\');\\n\\n// 플러그인 존재 확인\\nif (engine.hasPlugin(\'shape\')) {\\n  console.log(\'Shape plugin is installed\');\\n}\\n\\n// 플러그인 제거\\nengine.remove(\'shape\');\\n```\\n\\n## 관련 API\\n\\n- [Plugin](/docs/api-reference/core/plugin) - 플러그인 인터페이스\\n- [Service](/docs/api-reference/core/service) - 서비스 시스템\\n- [CanvasRendererPlugin](/docs/api-reference/renderers/canvas-renderer) - Canvas 렌더러 플러그인 ","html":"<h1>VectorEngine</h1>\\n<p><code>VectorEngine</code>은 Modern Vector.js의 핵심 클래스로, 벡터 그래픽 시스템의 중앙 제어 지점 역할을 합니다. 이 클래스는 플러그인 관리, 서비스 제공, 렌더링 조정 등 라이브러리의 모든 주요 기능을 관리합니다.</p>\\n<h2>구문</h2>\\n<pre><code class=\\"language-typescript\\">class VectorEngine {\\n  constructor(options?: VectorEngineOptions);\\n  \\n  // 플러그인 관리\\n  use&#x3C;T extends Plugin>(plugin: T): this;\\n  remove(pluginId: string): boolean;\\n  getPlugin&#x3C;T extends Plugin>(id: string): T | undefined;\\n  hasPlugin(id: string): boolean;\\n  \\n  // 서비스 관리\\n  registerService&#x3C;T>(serviceId: string, service: T): this;\\n  getService&#x3C;T>(serviceId: string): T | undefined;\\n  \\n  // 렌더링 및 업데이트\\n  render(): void;\\n  update(deltaTime: number): void;\\n  \\n  // 이벤트 관리\\n  on&#x3C;K extends keyof EngineEvents>(event: K, listener: EngineEventListener&#x3C;K>): this;\\n  off&#x3C;K extends keyof EngineEvents>(event: K, listener: EngineEventListener&#x3C;K>): this;\\n  emit&#x3C;K extends keyof EngineEvents>(event: K, ...args: Parameters&#x3C;EngineEventListener&#x3C;K>>): boolean;\\n  \\n  // 리소스 관리\\n  dispose(): void;\\n}\\n</code></pre>\\n<h2>생성자</h2>\\n<h3><code>constructor(options?: VectorEngineOptions)</code></h3>\\n<p>VectorEngine 인스턴스를 생성합니다.</p>\\n<h4>매개변수</h4>\\n<ul>\\n<li><code>options</code> (선택사항): 엔진 초기화 옵션\\n<ul>\\n<li><code>autoRender</code> (boolean): 자동 렌더링 활성화 여부 (기본값: <code>true</code>)</li>\\n<li><code>plugins</code> (Plugin[]): 초기화 시 등록할 플러그인 배열</li>\\n<li><code>services</code> (Record&#x3C;string, any>): 초기화 시 등록할 서비스 객체</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>메서드</h2>\\n<h3>플러그인 관리</h3>\\n<h4><code>use&#x3C;T extends Plugin>(plugin: T): this</code></h4>\\n<p>플러그인을 엔진에 등록합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>plugin</code> - 등록할 플러그인 인스턴스</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>remove(pluginId: string): boolean</code></h4>\\n<p>ID로 플러그인을 제거합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>pluginId</code> - 제거할 플러그인의 ID</li>\\n<li><strong>반환값</strong>: 제거 성공 여부</li>\\n</ul>\\n<h4><code>getPlugin&#x3C;T extends Plugin>(id: string): T | undefined</code></h4>\\n<p>ID로 플러그인을 조회합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>id</code> - 조회할 플러그인의 ID</li>\\n<li><strong>반환값</strong>: 플러그인 인스턴스 또는 undefined</li>\\n</ul>\\n<h4><code>hasPlugin(id: string): boolean</code></h4>\\n<p>특정 ID의 플러그인이 등록되어 있는지 확인합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>id</code> - 확인할 플러그인의 ID</li>\\n<li><strong>반환값</strong>: 플러그인 존재 여부</li>\\n</ul>\\n<h3>서비스 관리</h3>\\n<h4><code>registerService&#x3C;T>(serviceId: string, service: T): this</code></h4>\\n<p>서비스를 엔진에 등록합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>:\\n<ul>\\n<li><code>serviceId</code> - 서비스 식별자</li>\\n<li><code>service</code> - 서비스 인스턴스</li>\\n</ul>\\n</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>getService&#x3C;T>(serviceId: string): T | undefined</code></h4>\\n<p>ID로 서비스를 조회합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>serviceId</code> - 조회할 서비스의 ID</li>\\n<li><strong>반환값</strong>: 서비스 인스턴스 또는 undefined</li>\\n</ul>\\n<h3>렌더링 및 업데이트</h3>\\n<h4><code>render(): void</code></h4>\\n<p>현재 장면을 렌더링합니다. 등록된 렌더러 플러그인을 통해 실행됩니다.</p>\\n<h4><code>update(deltaTime: number): void</code></h4>\\n<p>엔진 상태를 업데이트합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>deltaTime</code> - 이전 프레임과의 시간 차이(밀리초)</li>\\n</ul>\\n<h3>이벤트 관리</h3>\\n<h4><code>on&#x3C;K extends keyof EngineEvents>(event: K, listener: EngineEventListener&#x3C;K>): this</code></h4>\\n<p>이벤트 리스너를 등록합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>:\\n<ul>\\n<li><code>event</code> - 이벤트 이름</li>\\n<li><code>listener</code> - 이벤트 핸들러 함수</li>\\n</ul>\\n</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>off&#x3C;K extends keyof EngineEvents>(event: K, listener: EngineEventListener&#x3C;K>): this</code></h4>\\n<p>이벤트 리스너를 제거합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>:\\n<ul>\\n<li><code>event</code> - 이벤트 이름</li>\\n<li><code>listener</code> - 제거할 이벤트 핸들러 함수</li>\\n</ul>\\n</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>emit&#x3C;K extends keyof EngineEvents>(event: K, ...args: Parameters&#x3C;EngineEventListener&#x3C;K>>): boolean</code></h4>\\n<p>이벤트를 발생시킵니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>:\\n<ul>\\n<li><code>event</code> - 발생시킬 이벤트 이름</li>\\n<li><code>args</code> - 이벤트 핸들러에 전달할 인자들</li>\\n</ul>\\n</li>\\n<li><strong>반환값</strong>: 이벤트가 처리되었는지 여부</li>\\n</ul>\\n<h3>리소스 관리</h3>\\n<h4><code>dispose(): void</code></h4>\\n<p>엔진과 관련된 모든 리소스를 정리합니다. 등록된 모든 플러그인의 <code>uninstall</code> 메서드를 호출합니다.</p>\\n<h2>예제</h2>\\n<h3>기본 사용법</h3>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine } from \'modern-vector\';\\nimport { CanvasRendererPlugin } from \'modern-vector/plugins/canvas-renderer\';\\nimport { ShapePlugin } from \'modern-vector/plugins/shape\';\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// 플러그인 등록\\nengine.use(new CanvasRendererPlugin({ canvas: document.getElementById(\'canvas\') }))\\n      .use(new ShapePlugin());\\n\\n// 서비스 등록\\nengine.registerService(\'logger\', {\\n  log: (message: string) => console.log(`[Vector]: ${message}`)\\n});\\n\\n// 이벤트 리스너 등록\\nengine.on(\'render\', () => {\\n  console.log(\'Scene rendered\');\\n});\\n\\n// 렌더링 실행\\nengine.render();\\n\\n// 리소스 정리\\n// engine.dispose();\\n</code></pre>\\n<h3>플러그인 관리</h3>\\n<pre><code class=\\"language-typescript\\">// 플러그인 등록\\nengine.use(new ShapePlugin());\\n\\n// 플러그인 조회\\nconst shapePlugin = engine.getPlugin&#x3C;ShapePlugin>(\'shape\');\\n\\n// 플러그인 존재 확인\\nif (engine.hasPlugin(\'shape\')) {\\n  console.log(\'Shape plugin is installed\');\\n}\\n\\n// 플러그인 제거\\nengine.remove(\'shape\');\\n</code></pre>\\n<h2>관련 API</h2>\\n<ul>\\n<li><a href=\\"/docs/api-reference/core/plugin\\">Plugin</a> - 플러그인 인터페이스</li>\\n<li><a href=\\"/docs/api-reference/core/service\\">Service</a> - 서비스 시스템</li>\\n<li><a href=\\"/docs/api-reference/renderers/canvas-renderer\\">CanvasRendererPlugin</a> - Canvas 렌더러 플러그인</li>\\n</ul>"},"_id":"docs/api-reference/core/vector-engine.md","_raw":{"sourceFilePath":"docs/api-reference/core/vector-engine.md","sourceFileName":"vector-engine.md","sourceFileDir":"docs/api-reference/core","contentType":"markdown","flattenedPath":"docs/api-reference/core/vector-engine"},"type":"Doc","slug":"api-reference/core/vector-engine","url":"/docs/api-reference/core/vector-engine"},{"title":"Vector","description":"벡터 연산을 위한 클래스 및 함수에 대한 API 문서","body":{"raw":"\\n# Vector\\n\\n`Vector` 클래스는 2D 및 3D 벡터 연산을 위한 유틸리티를 제공합니다. 이 클래스는 점, 방향, 속도 등을 표현하는 데 사용되며, 벡터 수학 연산을 위한 다양한 메서드를 제공합니다.\\n\\n## 구문\\n\\n```typescript\\nclass Vector {\\n  constructor(x?: number, y?: number, z?: number);\\n  \\n  // 속성\\n  x: number;\\n  y: number;\\n  z: number;\\n  \\n  // 기본 연산\\n  set(x: number, y: number, z?: number): this;\\n  copy(v: Vector): this;\\n  clone(): Vector;\\n  \\n  // 벡터 연산\\n  add(v: Vector): this;\\n  addScalar(s: number): this;\\n  subtract(v: Vector): this;\\n  subtractScalar(s: number): this;\\n  multiply(v: Vector): this;\\n  multiplyScalar(s: number): this;\\n  divide(v: Vector): this;\\n  divideScalar(s: number): this;\\n  \\n  // 벡터 속성\\n  length(): number;\\n  lengthSquared(): number;\\n  distance(v: Vector): number;\\n  distanceSquared(v: Vector): number;\\n  normalize(): this;\\n  \\n  // 벡터 변환\\n  negate(): this;\\n  inverse(): this;\\n  \\n  // 벡터 연산\\n  dot(v: Vector): number;\\n  cross(v: Vector): Vector;\\n  \\n  // 벡터 변환\\n  applyMatrix(m: Matrix): this;\\n  applyQuaternion(q: Quaternion): this;\\n  \\n  // 유틸리티\\n  equals(v: Vector, epsilon?: number): boolean;\\n  toString(): string;\\n  toArray(): [number, number, number];\\n  \\n  // 정적 메서드\\n  static add(a: Vector, b: Vector): Vector;\\n  static subtract(a: Vector, b: Vector): Vector;\\n  static multiply(a: Vector, b: Vector): Vector;\\n  static divide(a: Vector, b: Vector): Vector;\\n  static dot(a: Vector, b: Vector): number;\\n  static cross(a: Vector, b: Vector): Vector;\\n}\\n```\\n\\n## 생성자\\n\\n### `constructor(x?: number, y?: number, z?: number)`\\n\\n새로운 Vector 인스턴스를 생성합니다.\\n\\n#### 매개변수\\n\\n- `x` (선택사항): x 좌표. 기본값: 0\\n- `y` (선택사항): y 좌표. 기본값: 0\\n- `z` (선택사항): z 좌표. 기본값: 0\\n\\n## 속성\\n\\n### `x: number`\\n\\n벡터의 x 좌표\\n\\n### `y: number`\\n\\n벡터의 y 좌표\\n\\n### `z: number`\\n\\n벡터의 z 좌표\\n\\n## 메서드\\n\\n### 기본 연산\\n\\n#### `set(x: number, y: number, z?: number): this`\\n\\n벡터의 좌표를 설정합니다.\\n\\n- **매개변수**:\\n  - `x`: 새 x 좌표\\n  - `y`: 새 y 좌표\\n  - `z` (선택사항): 새 z 좌표. 기본값: 0\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `copy(v: Vector): this`\\n\\n다른 벡터의 좌표를 현재 벡터로 복사합니다.\\n\\n- **매개변수**: `v` - 복사할 벡터\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `clone(): Vector`\\n\\n현재 벡터의 복제본을 생성합니다.\\n\\n- **반환값**: 새로운 Vector 인스턴스\\n\\n### 벡터 연산\\n\\n#### `add(v: Vector): this`\\n\\n현재 벡터에 다른 벡터를 더합니다.\\n\\n- **매개변수**: `v` - 더할 벡터\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `addScalar(s: number): this`\\n\\n현재 벡터의 모든 좌표에 스칼라 값을 더합니다.\\n\\n- **매개변수**: `s` - 더할 스칼라 값\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `subtract(v: Vector): this`\\n\\n현재 벡터에서 다른 벡터를 뺍니다.\\n\\n- **매개변수**: `v` - 뺄 벡터\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n#### `subtractScalar(s: number): this`\\n\\n현재 벡터의 모든 좌표에서 스칼라 값을 뺍니다.\\n\\n- **매개변수**: `s` - 뺄 스칼라 값\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n## 예제\\n\\n### 기본 사용법\\n\\n```typescript\\nimport { Vector } from \'modern-vector\';\\n\\n// 벡터 생성\\nconst v1 = new Vector(1, 2, 3);\\nconst v2 = new Vector(4, 5, 6);\\n\\n// 벡터 연산\\nconst v3 = v1.clone().add(v2);\\nconsole.log(v3.toString()); // \\"Vector(5, 7, 9)\\"\\n\\n// 벡터 정규화\\nconst direction = new Vector(3, 4, 0).normalize();\\nconsole.log(direction.length()); // 1\\nconsole.log(direction.toString()); // \\"Vector(0.6, 0.8, 0)\\"\\n\\n// 벡터 내적\\nconst dotProduct = v1.dot(v2);\\nconsole.log(dotProduct); // 32\\n\\n// 벡터 외적\\nconst crossProduct = v1.clone().cross(v2);\\nconsole.log(crossProduct.toString()); // \\"Vector(-3, 6, -3)\\"\\n```\\n\\n### 벡터 변환\\n\\n```typescript\\nimport { Vector, Matrix } from \'modern-vector\';\\n\\n// 벡터 생성\\nconst position = new Vector(10, 20, 30);\\n\\n// 행렬 변환\\nconst transformMatrix = Matrix.createRotationZ(Math.PI / 4); // 45도 회전\\nposition.applyMatrix(transformMatrix);\\n\\nconsole.log(position.toString()); // 회전된 위치\\n```\\n\\n## 관련 API\\n\\n- [Matrix](/docs/api-reference/math/matrix) - 행렬 연산\\n- [Quaternion](/docs/api-reference/math/quaternion) - 쿼터니언 연산\\n- [Transform](/docs/api-reference/math/transform) - 변환 유틸리티 ","html":"<h1>Vector</h1>\\n<p><code>Vector</code> 클래스는 2D 및 3D 벡터 연산을 위한 유틸리티를 제공합니다. 이 클래스는 점, 방향, 속도 등을 표현하는 데 사용되며, 벡터 수학 연산을 위한 다양한 메서드를 제공합니다.</p>\\n<h2>구문</h2>\\n<pre><code class=\\"language-typescript\\">class Vector {\\n  constructor(x?: number, y?: number, z?: number);\\n  \\n  // 속성\\n  x: number;\\n  y: number;\\n  z: number;\\n  \\n  // 기본 연산\\n  set(x: number, y: number, z?: number): this;\\n  copy(v: Vector): this;\\n  clone(): Vector;\\n  \\n  // 벡터 연산\\n  add(v: Vector): this;\\n  addScalar(s: number): this;\\n  subtract(v: Vector): this;\\n  subtractScalar(s: number): this;\\n  multiply(v: Vector): this;\\n  multiplyScalar(s: number): this;\\n  divide(v: Vector): this;\\n  divideScalar(s: number): this;\\n  \\n  // 벡터 속성\\n  length(): number;\\n  lengthSquared(): number;\\n  distance(v: Vector): number;\\n  distanceSquared(v: Vector): number;\\n  normalize(): this;\\n  \\n  // 벡터 변환\\n  negate(): this;\\n  inverse(): this;\\n  \\n  // 벡터 연산\\n  dot(v: Vector): number;\\n  cross(v: Vector): Vector;\\n  \\n  // 벡터 변환\\n  applyMatrix(m: Matrix): this;\\n  applyQuaternion(q: Quaternion): this;\\n  \\n  // 유틸리티\\n  equals(v: Vector, epsilon?: number): boolean;\\n  toString(): string;\\n  toArray(): [number, number, number];\\n  \\n  // 정적 메서드\\n  static add(a: Vector, b: Vector): Vector;\\n  static subtract(a: Vector, b: Vector): Vector;\\n  static multiply(a: Vector, b: Vector): Vector;\\n  static divide(a: Vector, b: Vector): Vector;\\n  static dot(a: Vector, b: Vector): number;\\n  static cross(a: Vector, b: Vector): Vector;\\n}\\n</code></pre>\\n<h2>생성자</h2>\\n<h3><code>constructor(x?: number, y?: number, z?: number)</code></h3>\\n<p>새로운 Vector 인스턴스를 생성합니다.</p>\\n<h4>매개변수</h4>\\n<ul>\\n<li><code>x</code> (선택사항): x 좌표. 기본값: 0</li>\\n<li><code>y</code> (선택사항): y 좌표. 기본값: 0</li>\\n<li><code>z</code> (선택사항): z 좌표. 기본값: 0</li>\\n</ul>\\n<h2>속성</h2>\\n<h3><code>x: number</code></h3>\\n<p>벡터의 x 좌표</p>\\n<h3><code>y: number</code></h3>\\n<p>벡터의 y 좌표</p>\\n<h3><code>z: number</code></h3>\\n<p>벡터의 z 좌표</p>\\n<h2>메서드</h2>\\n<h3>기본 연산</h3>\\n<h4><code>set(x: number, y: number, z?: number): this</code></h4>\\n<p>벡터의 좌표를 설정합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>:\\n<ul>\\n<li><code>x</code>: 새 x 좌표</li>\\n<li><code>y</code>: 새 y 좌표</li>\\n<li><code>z</code> (선택사항): 새 z 좌표. 기본값: 0</li>\\n</ul>\\n</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>copy(v: Vector): this</code></h4>\\n<p>다른 벡터의 좌표를 현재 벡터로 복사합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>v</code> - 복사할 벡터</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>clone(): Vector</code></h4>\\n<p>현재 벡터의 복제본을 생성합니다.</p>\\n<ul>\\n<li><strong>반환값</strong>: 새로운 Vector 인스턴스</li>\\n</ul>\\n<h3>벡터 연산</h3>\\n<h4><code>add(v: Vector): this</code></h4>\\n<p>현재 벡터에 다른 벡터를 더합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>v</code> - 더할 벡터</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>addScalar(s: number): this</code></h4>\\n<p>현재 벡터의 모든 좌표에 스칼라 값을 더합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>s</code> - 더할 스칼라 값</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>subtract(v: Vector): this</code></h4>\\n<p>현재 벡터에서 다른 벡터를 뺍니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>v</code> - 뺄 벡터</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h4><code>subtractScalar(s: number): this</code></h4>\\n<p>현재 벡터의 모든 좌표에서 스칼라 값을 뺍니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>s</code> - 뺄 스칼라 값</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h2>예제</h2>\\n<h3>기본 사용법</h3>\\n<pre><code class=\\"language-typescript\\">import { Vector } from \'modern-vector\';\\n\\n// 벡터 생성\\nconst v1 = new Vector(1, 2, 3);\\nconst v2 = new Vector(4, 5, 6);\\n\\n// 벡터 연산\\nconst v3 = v1.clone().add(v2);\\nconsole.log(v3.toString()); // \\"Vector(5, 7, 9)\\"\\n\\n// 벡터 정규화\\nconst direction = new Vector(3, 4, 0).normalize();\\nconsole.log(direction.length()); // 1\\nconsole.log(direction.toString()); // \\"Vector(0.6, 0.8, 0)\\"\\n\\n// 벡터 내적\\nconst dotProduct = v1.dot(v2);\\nconsole.log(dotProduct); // 32\\n\\n// 벡터 외적\\nconst crossProduct = v1.clone().cross(v2);\\nconsole.log(crossProduct.toString()); // \\"Vector(-3, 6, -3)\\"\\n</code></pre>\\n<h3>벡터 변환</h3>\\n<pre><code class=\\"language-typescript\\">import { Vector, Matrix } from \'modern-vector\';\\n\\n// 벡터 생성\\nconst position = new Vector(10, 20, 30);\\n\\n// 행렬 변환\\nconst transformMatrix = Matrix.createRotationZ(Math.PI / 4); // 45도 회전\\nposition.applyMatrix(transformMatrix);\\n\\nconsole.log(position.toString()); // 회전된 위치\\n</code></pre>\\n<h2>관련 API</h2>\\n<ul>\\n<li><a href=\\"/docs/api-reference/math/matrix\\">Matrix</a> - 행렬 연산</li>\\n<li><a href=\\"/docs/api-reference/math/quaternion\\">Quaternion</a> - 쿼터니언 연산</li>\\n<li><a href=\\"/docs/api-reference/math/transform\\">Transform</a> - 변환 유틸리티</li>\\n</ul>"},"_id":"docs/api-reference/math/vector.md","_raw":{"sourceFilePath":"docs/api-reference/math/vector.md","sourceFileName":"vector.md","sourceFileDir":"docs/api-reference/math","contentType":"markdown","flattenedPath":"docs/api-reference/math/vector"},"type":"Doc","slug":"api-reference/math/vector","url":"/docs/api-reference/math/vector"},{"title":"CanvasRenderer","description":"Canvas API를 사용한 렌더링을 위한 플러그인 문서","body":{"raw":"\\n# CanvasRenderer\\n\\n`CanvasRendererPlugin`은 HTML5 Canvas API를 사용하여 벡터 그래픽을 렌더링하는 플러그인입니다. 이 플러그인은 2D 컨텍스트를 사용하여 벡터 도형, 경로, 텍스트 등을 렌더링합니다.\\n\\n## 구문\\n\\n```typescript\\nclass CanvasRendererPlugin implements Plugin {\\n  readonly id = \'canvas-renderer\';\\n  readonly version = \'1.0.0\';\\n  \\n  constructor(options?: CanvasRendererOptions);\\n  \\n  install(engine: VectorEngine): void;\\n  uninstall(engine: VectorEngine): void;\\n  \\n  // 렌더링 메서드\\n  render(scene: Scene): void;\\n  clear(): void;\\n  resize(width: number, height: number): void;\\n  \\n  // 유틸리티 메서드\\n  getCanvas(): HTMLCanvasElement;\\n  getContext(): CanvasRenderingContext2D;\\n}\\n```\\n\\n## 옵션\\n\\n```typescript\\ninterface CanvasRendererOptions {\\n  canvas?: HTMLCanvasElement;\\n  width?: number;\\n  height?: number;\\n  pixelRatio?: number;\\n  alpha?: boolean;\\n  antialias?: boolean;\\n  clearColor?: string;\\n  autoResize?: boolean;\\n}\\n```\\n\\n### 옵션 설명\\n\\n- `canvas`: 사용할 Canvas 요소. 제공되지 않으면 새로운 Canvas 요소가 생성됩니다.\\n- `width`: Canvas의 너비 (픽셀). 기본값: 800\\n- `height`: Canvas의 높이 (픽셀). 기본값: 600\\n- `pixelRatio`: 장치 픽셀 비율. 기본값: `window.devicePixelRatio` 또는 1\\n- `alpha`: Canvas 컨텍스트의 알파 채널 활성화 여부. 기본값: true\\n- `antialias`: 안티앨리어싱 활성화 여부. 기본값: true\\n- `clearColor`: 화면 지우기에 사용되는 색상. 기본값: \'transparent\'\\n- `autoResize`: 창 크기 변경 시 자동 리사이징 활성화 여부. 기본값: false\\n\\n## 메서드\\n\\n### 렌더링 메서드\\n\\n#### `render(scene: Scene): void`\\n\\n장면을 Canvas에 렌더링합니다.\\n\\n- **매개변수**: `scene` - 렌더링할 장면 객체\\n\\n#### `clear(): void`\\n\\nCanvas를 지정된 `clearColor`로 지웁니다.\\n\\n#### `resize(width: number, height: number): void`\\n\\nCanvas 크기를 조정합니다.\\n\\n- **매개변수**:\\n  - `width` - 새 너비 (픽셀)\\n  - `height` - 새 높이 (픽셀)\\n\\n### 유틸리티 메서드\\n\\n#### `getCanvas(): HTMLCanvasElement`\\n\\n현재 사용 중인 Canvas 요소를 반환합니다.\\n\\n- **반환값**: Canvas 요소\\n\\n#### `getContext(): CanvasRenderingContext2D`\\n\\nCanvas의 2D 렌더링 컨텍스트를 반환합니다.\\n\\n- **반환값**: 2D 렌더링 컨텍스트\\n\\n## 서비스\\n\\nCanvasRendererPlugin은 다음 서비스를 등록합니다:\\n\\n### CanvasRendererService\\n\\n```typescript\\ninterface CanvasRendererService {\\n  render(scene: Scene): void;\\n  clear(): void;\\n  resize(width: number, height: number): void;\\n  getCanvas(): HTMLCanvasElement;\\n  getContext(): CanvasRenderingContext2D;\\n  setTransform(transform: Matrix): void;\\n  resetTransform(): void;\\n  drawShape(shape: Shape): void;\\n  drawPath(path: Path): void;\\n  drawImage(image: HTMLImageElement, x: number, y: number, width?: number, height?: number): void;\\n  measureText(text: string, font?: string): TextMetrics;\\n}\\n```\\n\\n## 예제\\n\\n### 기본 사용법\\n\\n```typescript\\nimport { VectorEngine } from \'modern-vector\';\\nimport { CanvasRendererPlugin } from \'modern-vector/plugins/canvas-renderer\';\\nimport { ShapePlugin } from \'modern-vector/plugins/shape\';\\n\\n// Canvas 요소 가져오기\\nconst canvas = document.getElementById(\'canvas\') as HTMLCanvasElement;\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// Canvas 렌더러 플러그인 등록\\nengine.use(new CanvasRendererPlugin({\\n  canvas,\\n  width: 800,\\n  height: 600,\\n  pixelRatio: window.devicePixelRatio,\\n  clearColor: \'#ffffff\',\\n  autoResize: true\\n}));\\n\\n// 도형 플러그인 등록\\nengine.use(new ShapePlugin());\\n\\n// 렌더러 서비스 가져오기\\nconst rendererService = engine.getService<CanvasRendererService>(\'canvas-renderer\');\\n\\n// 장면 생성 및 렌더링\\nconst scene = {\\n  shapes: [\\n    // 도형 정의\\n  ]\\n};\\n\\n// 렌더링\\nrendererService.clear();\\nrendererService.render(scene);\\n\\n// 창 크기 변경 이벤트 처리\\nwindow.addEventListener(\'resize\', () => {\\n  rendererService.resize(window.innerWidth, window.innerHeight);\\n  rendererService.render(scene);\\n});\\n```\\n\\n### 고급 사용법\\n\\n```typescript\\nimport { VectorEngine } from \'modern-vector\';\\nimport { CanvasRendererPlugin } from \'modern-vector/plugins/canvas-renderer\';\\n\\nconst engine = new VectorEngine();\\nconst renderer = new CanvasRendererPlugin();\\n\\nengine.use(renderer);\\n\\n// 렌더러 서비스 가져오기\\nconst rendererService = engine.getService<CanvasRendererService>(\'canvas-renderer\');\\n\\n// Canvas 컨텍스트 직접 사용\\nconst ctx = rendererService.getContext();\\n\\n// 사용자 정의 그리기 작업\\nfunction customDraw() {\\n  const ctx = rendererService.getContext();\\n  \\n  // 상태 저장\\n  ctx.save();\\n  \\n  // 그리기 설정\\n  ctx.fillStyle = \'red\';\\n  ctx.strokeStyle = \'blue\';\\n  ctx.lineWidth = 2;\\n  \\n  // 도형 그리기\\n  ctx.beginPath();\\n  ctx.moveTo(100, 100);\\n  ctx.lineTo(200, 100);\\n  ctx.lineTo(200, 200);\\n  ctx.lineTo(100, 200);\\n  ctx.closePath();\\n  ctx.fill();\\n  ctx.stroke();\\n  \\n  // 상태 복원\\n  ctx.restore();\\n}\\n\\n// 애니메이션 루프\\nlet lastTime = 0;\\nfunction animate(time: number) {\\n  const deltaTime = time - lastTime;\\n  lastTime = time;\\n  \\n  // 화면 지우기\\n  rendererService.clear();\\n  \\n  // 사용자 정의 그리기\\n  customDraw();\\n  \\n  // 다음 프레임 요청\\n  requestAnimationFrame(animate);\\n}\\n\\n// 애니메이션 시작\\nrequestAnimationFrame(animate);\\n```\\n\\n## 성능 최적화 팁\\n\\n1. **불필요한 상태 변경 최소화**: Canvas 컨텍스트의 상태 변경(fillStyle, strokeStyle 등)은 비용이 많이 들 수 있습니다. 유사한 스타일의 도형을 함께 그리세요.\\n\\n2. **오프스크린 렌더링 사용**: 자주 변경되지 않는 복잡한 도형은 오프스크린 Canvas에 미리 렌더링한 다음 메인 Canvas에 복사하세요.\\n\\n3. **적절한 Canvas 크기 사용**: Canvas가 너무 크면 렌더링 성능이 저하될 수 있습니다. 필요한 크기만 사용하세요.\\n\\n4. **requestAnimationFrame 사용**: 애니메이션에는 항상 `setTimeout` 대신 `requestAnimationFrame`을 사용하세요.\\n\\n5. **Canvas 상태 저장/복원 최소화**: `save()`와 `restore()` 호출은 비용이 많이 들 수 있습니다. 필요한 경우에만 사용하세요.\\n\\n## 브라우저 호환성\\n\\nCanvasRendererPlugin은 Canvas API를 지원하는 모든 최신 브라우저에서 작동합니다:\\n\\n- Chrome 4+\\n- Firefox 2+\\n- Safari 3.1+\\n- Edge 12+\\n- Opera 9+\\n- iOS Safari 3.2+ ","html":"<h1>CanvasRenderer</h1>\\n<p><code>CanvasRendererPlugin</code>은 HTML5 Canvas API를 사용하여 벡터 그래픽을 렌더링하는 플러그인입니다. 이 플러그인은 2D 컨텍스트를 사용하여 벡터 도형, 경로, 텍스트 등을 렌더링합니다.</p>\\n<h2>구문</h2>\\n<pre><code class=\\"language-typescript\\">class CanvasRendererPlugin implements Plugin {\\n  readonly id = \'canvas-renderer\';\\n  readonly version = \'1.0.0\';\\n  \\n  constructor(options?: CanvasRendererOptions);\\n  \\n  install(engine: VectorEngine): void;\\n  uninstall(engine: VectorEngine): void;\\n  \\n  // 렌더링 메서드\\n  render(scene: Scene): void;\\n  clear(): void;\\n  resize(width: number, height: number): void;\\n  \\n  // 유틸리티 메서드\\n  getCanvas(): HTMLCanvasElement;\\n  getContext(): CanvasRenderingContext2D;\\n}\\n</code></pre>\\n<h2>옵션</h2>\\n<pre><code class=\\"language-typescript\\">interface CanvasRendererOptions {\\n  canvas?: HTMLCanvasElement;\\n  width?: number;\\n  height?: number;\\n  pixelRatio?: number;\\n  alpha?: boolean;\\n  antialias?: boolean;\\n  clearColor?: string;\\n  autoResize?: boolean;\\n}\\n</code></pre>\\n<h3>옵션 설명</h3>\\n<ul>\\n<li><code>canvas</code>: 사용할 Canvas 요소. 제공되지 않으면 새로운 Canvas 요소가 생성됩니다.</li>\\n<li><code>width</code>: Canvas의 너비 (픽셀). 기본값: 800</li>\\n<li><code>height</code>: Canvas의 높이 (픽셀). 기본값: 600</li>\\n<li><code>pixelRatio</code>: 장치 픽셀 비율. 기본값: <code>window.devicePixelRatio</code> 또는 1</li>\\n<li><code>alpha</code>: Canvas 컨텍스트의 알파 채널 활성화 여부. 기본값: true</li>\\n<li><code>antialias</code>: 안티앨리어싱 활성화 여부. 기본값: true</li>\\n<li><code>clearColor</code>: 화면 지우기에 사용되는 색상. 기본값: \'transparent\'</li>\\n<li><code>autoResize</code>: 창 크기 변경 시 자동 리사이징 활성화 여부. 기본값: false</li>\\n</ul>\\n<h2>메서드</h2>\\n<h3>렌더링 메서드</h3>\\n<h4><code>render(scene: Scene): void</code></h4>\\n<p>장면을 Canvas에 렌더링합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>: <code>scene</code> - 렌더링할 장면 객체</li>\\n</ul>\\n<h4><code>clear(): void</code></h4>\\n<p>Canvas를 지정된 <code>clearColor</code>로 지웁니다.</p>\\n<h4><code>resize(width: number, height: number): void</code></h4>\\n<p>Canvas 크기를 조정합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>:\\n<ul>\\n<li><code>width</code> - 새 너비 (픽셀)</li>\\n<li><code>height</code> - 새 높이 (픽셀)</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>유틸리티 메서드</h3>\\n<h4><code>getCanvas(): HTMLCanvasElement</code></h4>\\n<p>현재 사용 중인 Canvas 요소를 반환합니다.</p>\\n<ul>\\n<li><strong>반환값</strong>: Canvas 요소</li>\\n</ul>\\n<h4><code>getContext(): CanvasRenderingContext2D</code></h4>\\n<p>Canvas의 2D 렌더링 컨텍스트를 반환합니다.</p>\\n<ul>\\n<li><strong>반환값</strong>: 2D 렌더링 컨텍스트</li>\\n</ul>\\n<h2>서비스</h2>\\n<p>CanvasRendererPlugin은 다음 서비스를 등록합니다:</p>\\n<h3>CanvasRendererService</h3>\\n<pre><code class=\\"language-typescript\\">interface CanvasRendererService {\\n  render(scene: Scene): void;\\n  clear(): void;\\n  resize(width: number, height: number): void;\\n  getCanvas(): HTMLCanvasElement;\\n  getContext(): CanvasRenderingContext2D;\\n  setTransform(transform: Matrix): void;\\n  resetTransform(): void;\\n  drawShape(shape: Shape): void;\\n  drawPath(path: Path): void;\\n  drawImage(image: HTMLImageElement, x: number, y: number, width?: number, height?: number): void;\\n  measureText(text: string, font?: string): TextMetrics;\\n}\\n</code></pre>\\n<h2>예제</h2>\\n<h3>기본 사용법</h3>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine } from \'modern-vector\';\\nimport { CanvasRendererPlugin } from \'modern-vector/plugins/canvas-renderer\';\\nimport { ShapePlugin } from \'modern-vector/plugins/shape\';\\n\\n// Canvas 요소 가져오기\\nconst canvas = document.getElementById(\'canvas\') as HTMLCanvasElement;\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// Canvas 렌더러 플러그인 등록\\nengine.use(new CanvasRendererPlugin({\\n  canvas,\\n  width: 800,\\n  height: 600,\\n  pixelRatio: window.devicePixelRatio,\\n  clearColor: \'#ffffff\',\\n  autoResize: true\\n}));\\n\\n// 도형 플러그인 등록\\nengine.use(new ShapePlugin());\\n\\n// 렌더러 서비스 가져오기\\nconst rendererService = engine.getService&#x3C;CanvasRendererService>(\'canvas-renderer\');\\n\\n// 장면 생성 및 렌더링\\nconst scene = {\\n  shapes: [\\n    // 도형 정의\\n  ]\\n};\\n\\n// 렌더링\\nrendererService.clear();\\nrendererService.render(scene);\\n\\n// 창 크기 변경 이벤트 처리\\nwindow.addEventListener(\'resize\', () => {\\n  rendererService.resize(window.innerWidth, window.innerHeight);\\n  rendererService.render(scene);\\n});\\n</code></pre>\\n<h3>고급 사용법</h3>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine } from \'modern-vector\';\\nimport { CanvasRendererPlugin } from \'modern-vector/plugins/canvas-renderer\';\\n\\nconst engine = new VectorEngine();\\nconst renderer = new CanvasRendererPlugin();\\n\\nengine.use(renderer);\\n\\n// 렌더러 서비스 가져오기\\nconst rendererService = engine.getService&#x3C;CanvasRendererService>(\'canvas-renderer\');\\n\\n// Canvas 컨텍스트 직접 사용\\nconst ctx = rendererService.getContext();\\n\\n// 사용자 정의 그리기 작업\\nfunction customDraw() {\\n  const ctx = rendererService.getContext();\\n  \\n  // 상태 저장\\n  ctx.save();\\n  \\n  // 그리기 설정\\n  ctx.fillStyle = \'red\';\\n  ctx.strokeStyle = \'blue\';\\n  ctx.lineWidth = 2;\\n  \\n  // 도형 그리기\\n  ctx.beginPath();\\n  ctx.moveTo(100, 100);\\n  ctx.lineTo(200, 100);\\n  ctx.lineTo(200, 200);\\n  ctx.lineTo(100, 200);\\n  ctx.closePath();\\n  ctx.fill();\\n  ctx.stroke();\\n  \\n  // 상태 복원\\n  ctx.restore();\\n}\\n\\n// 애니메이션 루프\\nlet lastTime = 0;\\nfunction animate(time: number) {\\n  const deltaTime = time - lastTime;\\n  lastTime = time;\\n  \\n  // 화면 지우기\\n  rendererService.clear();\\n  \\n  // 사용자 정의 그리기\\n  customDraw();\\n  \\n  // 다음 프레임 요청\\n  requestAnimationFrame(animate);\\n}\\n\\n// 애니메이션 시작\\nrequestAnimationFrame(animate);\\n</code></pre>\\n<h2>성능 최적화 팁</h2>\\n<ol>\\n<li>\\n<p><strong>불필요한 상태 변경 최소화</strong>: Canvas 컨텍스트의 상태 변경(fillStyle, strokeStyle 등)은 비용이 많이 들 수 있습니다. 유사한 스타일의 도형을 함께 그리세요.</p>\\n</li>\\n<li>\\n<p><strong>오프스크린 렌더링 사용</strong>: 자주 변경되지 않는 복잡한 도형은 오프스크린 Canvas에 미리 렌더링한 다음 메인 Canvas에 복사하세요.</p>\\n</li>\\n<li>\\n<p><strong>적절한 Canvas 크기 사용</strong>: Canvas가 너무 크면 렌더링 성능이 저하될 수 있습니다. 필요한 크기만 사용하세요.</p>\\n</li>\\n<li>\\n<p><strong>requestAnimationFrame 사용</strong>: 애니메이션에는 항상 <code>setTimeout</code> 대신 <code>requestAnimationFrame</code>을 사용하세요.</p>\\n</li>\\n<li>\\n<p><strong>Canvas 상태 저장/복원 최소화</strong>: <code>save()</code>와 <code>restore()</code> 호출은 비용이 많이 들 수 있습니다. 필요한 경우에만 사용하세요.</p>\\n</li>\\n</ol>\\n<h2>브라우저 호환성</h2>\\n<p>CanvasRendererPlugin은 Canvas API를 지원하는 모든 최신 브라우저에서 작동합니다:</p>\\n<ul>\\n<li>Chrome 4+</li>\\n<li>Firefox 2+</li>\\n<li>Safari 3.1+</li>\\n<li>Edge 12+</li>\\n<li>Opera 9+</li>\\n<li>iOS Safari 3.2+</li>\\n</ul>"},"_id":"docs/api-reference/renderers/canvas-renderer.md","_raw":{"sourceFilePath":"docs/api-reference/renderers/canvas-renderer.md","sourceFileName":"canvas-renderer.md","sourceFileDir":"docs/api-reference/renderers","contentType":"markdown","flattenedPath":"docs/api-reference/renderers/canvas-renderer"},"type":"Doc","slug":"api-reference/renderers/canvas-renderer","url":"/docs/api-reference/renderers/canvas-renderer"},{"title":"Shape","description":"기본 도형 인터페이스에 대한 API 문서","body":{"raw":"\\n# Shape\\n\\n`Shape` 인터페이스는 Modern Vector.js에서 모든 벡터 도형의 기본 인터페이스입니다. 이 인터페이스는 도형의 공통 속성과 메서드를 정의하며, 라이브러리의 모든 도형 클래스는 이 인터페이스를 구현합니다.\\n\\n## 구문\\n\\n```typescript\\ninterface Shape {\\n  // 식별 및 메타데이터\\n  readonly id: string;\\n  name: string;\\n  type: ShapeType;\\n  \\n  // 위치 및 변환\\n  position: Vector;\\n  rotation: number;\\n  scale: Vector;\\n  origin: Vector;\\n  transform: Matrix;\\n  \\n  // 스타일 속성\\n  fill: FillStyle;\\n  stroke: StrokeStyle;\\n  opacity: number;\\n  visible: boolean;\\n  \\n  // 계층 구조\\n  parent: Shape | null;\\n  children: Shape[];\\n  \\n  // 바운딩 박스\\n  getBounds(): Bounds;\\n  getTransformedBounds(): Bounds;\\n  \\n  // 변환 메서드\\n  setPosition(x: number, y: number): this;\\n  setRotation(angle: number): this;\\n  setScale(x: number, y: number): this;\\n  setOrigin(x: number, y: number): this;\\n  \\n  // 계층 구조 메서드\\n  addChild(shape: Shape): this;\\n  removeChild(shape: Shape): boolean;\\n  \\n  // 렌더링 관련\\n  render(context: RenderContext): void;\\n  \\n  // 이벤트 관련\\n  on(event: ShapeEventType, listener: ShapeEventListener): this;\\n  off(event: ShapeEventType, listener: ShapeEventListener): this;\\n  \\n  // 유틸리티\\n  clone(): Shape;\\n  toJSON(): ShapeJSON;\\n  fromJSON(json: ShapeJSON): this;\\n}\\n```\\n\\n## 관련 타입\\n\\n### ShapeType\\n\\n```typescript\\nenum ShapeType {\\n  RECTANGLE = \'rectangle\',\\n  CIRCLE = \'circle\',\\n  ELLIPSE = \'ellipse\',\\n  LINE = \'line\',\\n  POLYLINE = \'polyline\',\\n  POLYGON = \'polygon\',\\n  PATH = \'path\',\\n  TEXT = \'text\',\\n  GROUP = \'group\',\\n  CUSTOM = \'custom\'\\n}\\n```\\n\\n### FillStyle\\n\\n```typescript\\ninterface FillStyle {\\n  color?: string;\\n  gradient?: Gradient;\\n  pattern?: Pattern;\\n  opacity?: number;\\n  enabled?: boolean;\\n}\\n```\\n\\n### StrokeStyle\\n\\n```typescript\\ninterface StrokeStyle {\\n  color?: string;\\n  width?: number;\\n  cap?: \'butt\' | \'round\' | \'square\';\\n  join?: \'miter\' | \'round\' | \'bevel\';\\n  miterLimit?: number;\\n  dash?: number[];\\n  dashOffset?: number;\\n  opacity?: number;\\n  enabled?: boolean;\\n}\\n```\\n\\n### Bounds\\n\\n```typescript\\ninterface Bounds {\\n  x: number;\\n  y: number;\\n  width: number;\\n  height: number;\\n}\\n```\\n\\n## 속성\\n\\n### 식별 및 메타데이터\\n\\n#### `id: string` (읽기 전용)\\n\\n도형의 고유 식별자입니다. 생성 시 자동으로 할당됩니다.\\n\\n#### `name: string`\\n\\n도형의 이름입니다. 사용자가 지정할 수 있습니다.\\n\\n#### `type: ShapeType`\\n\\n도형의 유형입니다. `ShapeType` 열거형의 값 중 하나입니다.\\n\\n### 위치 및 변환\\n\\n#### `position: Vector`\\n\\n도형의 위치(x, y 좌표)입니다.\\n\\n#### `rotation: number`\\n\\n도형의 회전 각도(라디안)입니다.\\n\\n#### `scale: Vector`\\n\\n도형의 x축 및 y축 크기 조정 비율입니다.\\n\\n#### `origin: Vector`\\n\\n도형의 원점(회전 및 크기 조정의 중심점)입니다.\\n\\n#### `transform: Matrix`\\n\\n도형의 변환 행렬입니다. 위치, 회전, 크기 조정 및 원점을 결합한 결과입니다.\\n\\n### 스타일 속성\\n\\n#### `fill: FillStyle`\\n\\n도형의 채우기 스타일입니다.\\n\\n#### `stroke: StrokeStyle`\\n\\n도형의 외곽선 스타일입니다.\\n\\n#### `opacity: number`\\n\\n도형의 전체 불투명도입니다. 0(완전 투명)에서 1(완전 불투명) 사이의 값입니다.\\n\\n#### `visible: boolean`\\n\\n도형의 가시성입니다. `false`인 경우 도형이 렌더링되지 않습니다.\\n\\n### 계층 구조\\n\\n#### `parent: Shape | null`\\n\\n도형의 부모 도형입니다. 최상위 도형인 경우 `null`입니다.\\n\\n#### `children: Shape[]`\\n\\n도형의 자식 도형 배열입니다.\\n\\n## 메서드\\n\\n### 바운딩 박스\\n\\n#### `getBounds(): Bounds`\\n\\n도형의 로컬 좌표계에서의 바운딩 박스를 반환합니다.\\n\\n- **반환값**: 바운딩 박스 객체\\n\\n#### `getTransformedBounds(): Bounds`\\n\\n도형의 변환(위치, 회전, 크기 조정)이 적용된 바운딩 박스를 반환합니다.\\n\\n- **반환값**: 변환된 바운딩 박스 객체\\n\\n### 변환 메서드\\n\\n#### `setPosition(x: number, y: number): this`\\n\\n도형의 위치를 설정합니다.\\n\\n- **매개변수**:\\n  - `x`: x 좌표\\n  - `y`: y 좌표\\n- **반환값**: 메서드 체이닝을 위한 현재 인스턴스\\n\\n## 예제\\n\\n### 기본 도형 생성 및 조작\\n\\n```typescript\\nimport { VectorEngine, RectangleShape } from \'modern-vector\';\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// 사각형 생성\\nconst rect = new RectangleShape({\\n  position: { x: 100, y: 100 },\\n  width: 200,\\n  height: 150,\\n  fill: { color: \'blue\', opacity: 0.8 },\\n  stroke: { color: \'black\', width: 2 }\\n});\\n\\n// 도형 변환\\nrect.setPosition(150, 150)\\n    .setRotation(Math.PI / 4) // 45도 회전\\n    .setScale(1.5, 1.5);      // 1.5배 확대\\n\\n// 장면에 도형 추가\\nengine.scene.add(rect);\\n\\n// 렌더링\\nengine.render();\\n```\\n\\n### 도형 계층 구조\\n\\n```typescript\\nimport { VectorEngine, GroupShape, CircleShape, RectangleShape } from \'modern-vector\';\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// 그룹 생성\\nconst group = new GroupShape({\\n  position: { x: 200, y: 200 }\\n});\\n\\n// 자식 도형 생성\\nconst circle = new CircleShape({\\n  position: { x: 0, y: 0 }, // 그룹 내 상대 위치\\n  radius: 50,\\n  fill: { color: \'red\' }\\n});\\n\\nconst rect = new RectangleShape({\\n  position: { x: 100, y: 0 }, // 그룹 내 상대 위치\\n  width: 80,\\n  height: 80,\\n  fill: { color: \'blue\' }\\n});\\n\\n// 그룹에 도형 추가\\ngroup.addChild(circle)\\n     .addChild(rect);\\n\\n// 그룹 회전 - 모든 자식 도형에 영향\\ngroup.setRotation(Math.PI / 6); // 30도 회전\\n\\n// 장면에 그룹 추가\\nengine.scene.add(group);\\n\\n// 렌더링\\nengine.render();\\n```\\n\\n## 관련 API\\n\\n- [Rectangle](/docs/api-reference/shapes/rectangle) - 사각형 도형\\n- [Circle](/docs/api-reference/shapes/circle) - 원형 도형\\n- [Path](/docs/api-reference/shapes/path) - 경로 도형\\n- [Group](/docs/api-reference/shapes/group) - 도형 그룹 ","html":"<h1>Shape</h1>\\n<p><code>Shape</code> 인터페이스는 Modern Vector.js에서 모든 벡터 도형의 기본 인터페이스입니다. 이 인터페이스는 도형의 공통 속성과 메서드를 정의하며, 라이브러리의 모든 도형 클래스는 이 인터페이스를 구현합니다.</p>\\n<h2>구문</h2>\\n<pre><code class=\\"language-typescript\\">interface Shape {\\n  // 식별 및 메타데이터\\n  readonly id: string;\\n  name: string;\\n  type: ShapeType;\\n  \\n  // 위치 및 변환\\n  position: Vector;\\n  rotation: number;\\n  scale: Vector;\\n  origin: Vector;\\n  transform: Matrix;\\n  \\n  // 스타일 속성\\n  fill: FillStyle;\\n  stroke: StrokeStyle;\\n  opacity: number;\\n  visible: boolean;\\n  \\n  // 계층 구조\\n  parent: Shape | null;\\n  children: Shape[];\\n  \\n  // 바운딩 박스\\n  getBounds(): Bounds;\\n  getTransformedBounds(): Bounds;\\n  \\n  // 변환 메서드\\n  setPosition(x: number, y: number): this;\\n  setRotation(angle: number): this;\\n  setScale(x: number, y: number): this;\\n  setOrigin(x: number, y: number): this;\\n  \\n  // 계층 구조 메서드\\n  addChild(shape: Shape): this;\\n  removeChild(shape: Shape): boolean;\\n  \\n  // 렌더링 관련\\n  render(context: RenderContext): void;\\n  \\n  // 이벤트 관련\\n  on(event: ShapeEventType, listener: ShapeEventListener): this;\\n  off(event: ShapeEventType, listener: ShapeEventListener): this;\\n  \\n  // 유틸리티\\n  clone(): Shape;\\n  toJSON(): ShapeJSON;\\n  fromJSON(json: ShapeJSON): this;\\n}\\n</code></pre>\\n<h2>관련 타입</h2>\\n<h3>ShapeType</h3>\\n<pre><code class=\\"language-typescript\\">enum ShapeType {\\n  RECTANGLE = \'rectangle\',\\n  CIRCLE = \'circle\',\\n  ELLIPSE = \'ellipse\',\\n  LINE = \'line\',\\n  POLYLINE = \'polyline\',\\n  POLYGON = \'polygon\',\\n  PATH = \'path\',\\n  TEXT = \'text\',\\n  GROUP = \'group\',\\n  CUSTOM = \'custom\'\\n}\\n</code></pre>\\n<h3>FillStyle</h3>\\n<pre><code class=\\"language-typescript\\">interface FillStyle {\\n  color?: string;\\n  gradient?: Gradient;\\n  pattern?: Pattern;\\n  opacity?: number;\\n  enabled?: boolean;\\n}\\n</code></pre>\\n<h3>StrokeStyle</h3>\\n<pre><code class=\\"language-typescript\\">interface StrokeStyle {\\n  color?: string;\\n  width?: number;\\n  cap?: \'butt\' | \'round\' | \'square\';\\n  join?: \'miter\' | \'round\' | \'bevel\';\\n  miterLimit?: number;\\n  dash?: number[];\\n  dashOffset?: number;\\n  opacity?: number;\\n  enabled?: boolean;\\n}\\n</code></pre>\\n<h3>Bounds</h3>\\n<pre><code class=\\"language-typescript\\">interface Bounds {\\n  x: number;\\n  y: number;\\n  width: number;\\n  height: number;\\n}\\n</code></pre>\\n<h2>속성</h2>\\n<h3>식별 및 메타데이터</h3>\\n<h4><code>id: string</code> (읽기 전용)</h4>\\n<p>도형의 고유 식별자입니다. 생성 시 자동으로 할당됩니다.</p>\\n<h4><code>name: string</code></h4>\\n<p>도형의 이름입니다. 사용자가 지정할 수 있습니다.</p>\\n<h4><code>type: ShapeType</code></h4>\\n<p>도형의 유형입니다. <code>ShapeType</code> 열거형의 값 중 하나입니다.</p>\\n<h3>위치 및 변환</h3>\\n<h4><code>position: Vector</code></h4>\\n<p>도형의 위치(x, y 좌표)입니다.</p>\\n<h4><code>rotation: number</code></h4>\\n<p>도형의 회전 각도(라디안)입니다.</p>\\n<h4><code>scale: Vector</code></h4>\\n<p>도형의 x축 및 y축 크기 조정 비율입니다.</p>\\n<h4><code>origin: Vector</code></h4>\\n<p>도형의 원점(회전 및 크기 조정의 중심점)입니다.</p>\\n<h4><code>transform: Matrix</code></h4>\\n<p>도형의 변환 행렬입니다. 위치, 회전, 크기 조정 및 원점을 결합한 결과입니다.</p>\\n<h3>스타일 속성</h3>\\n<h4><code>fill: FillStyle</code></h4>\\n<p>도형의 채우기 스타일입니다.</p>\\n<h4><code>stroke: StrokeStyle</code></h4>\\n<p>도형의 외곽선 스타일입니다.</p>\\n<h4><code>opacity: number</code></h4>\\n<p>도형의 전체 불투명도입니다. 0(완전 투명)에서 1(완전 불투명) 사이의 값입니다.</p>\\n<h4><code>visible: boolean</code></h4>\\n<p>도형의 가시성입니다. <code>false</code>인 경우 도형이 렌더링되지 않습니다.</p>\\n<h3>계층 구조</h3>\\n<h4><code>parent: Shape | null</code></h4>\\n<p>도형의 부모 도형입니다. 최상위 도형인 경우 <code>null</code>입니다.</p>\\n<h4><code>children: Shape[]</code></h4>\\n<p>도형의 자식 도형 배열입니다.</p>\\n<h2>메서드</h2>\\n<h3>바운딩 박스</h3>\\n<h4><code>getBounds(): Bounds</code></h4>\\n<p>도형의 로컬 좌표계에서의 바운딩 박스를 반환합니다.</p>\\n<ul>\\n<li><strong>반환값</strong>: 바운딩 박스 객체</li>\\n</ul>\\n<h4><code>getTransformedBounds(): Bounds</code></h4>\\n<p>도형의 변환(위치, 회전, 크기 조정)이 적용된 바운딩 박스를 반환합니다.</p>\\n<ul>\\n<li><strong>반환값</strong>: 변환된 바운딩 박스 객체</li>\\n</ul>\\n<h3>변환 메서드</h3>\\n<h4><code>setPosition(x: number, y: number): this</code></h4>\\n<p>도형의 위치를 설정합니다.</p>\\n<ul>\\n<li><strong>매개변수</strong>:\\n<ul>\\n<li><code>x</code>: x 좌표</li>\\n<li><code>y</code>: y 좌표</li>\\n</ul>\\n</li>\\n<li><strong>반환값</strong>: 메서드 체이닝을 위한 현재 인스턴스</li>\\n</ul>\\n<h2>예제</h2>\\n<h3>기본 도형 생성 및 조작</h3>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine, RectangleShape } from \'modern-vector\';\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// 사각형 생성\\nconst rect = new RectangleShape({\\n  position: { x: 100, y: 100 },\\n  width: 200,\\n  height: 150,\\n  fill: { color: \'blue\', opacity: 0.8 },\\n  stroke: { color: \'black\', width: 2 }\\n});\\n\\n// 도형 변환\\nrect.setPosition(150, 150)\\n    .setRotation(Math.PI / 4) // 45도 회전\\n    .setScale(1.5, 1.5);      // 1.5배 확대\\n\\n// 장면에 도형 추가\\nengine.scene.add(rect);\\n\\n// 렌더링\\nengine.render();\\n</code></pre>\\n<h3>도형 계층 구조</h3>\\n<pre><code class=\\"language-typescript\\">import { VectorEngine, GroupShape, CircleShape, RectangleShape } from \'modern-vector\';\\n\\n// 엔진 인스턴스 생성\\nconst engine = new VectorEngine();\\n\\n// 그룹 생성\\nconst group = new GroupShape({\\n  position: { x: 200, y: 200 }\\n});\\n\\n// 자식 도형 생성\\nconst circle = new CircleShape({\\n  position: { x: 0, y: 0 }, // 그룹 내 상대 위치\\n  radius: 50,\\n  fill: { color: \'red\' }\\n});\\n\\nconst rect = new RectangleShape({\\n  position: { x: 100, y: 0 }, // 그룹 내 상대 위치\\n  width: 80,\\n  height: 80,\\n  fill: { color: \'blue\' }\\n});\\n\\n// 그룹에 도형 추가\\ngroup.addChild(circle)\\n     .addChild(rect);\\n\\n// 그룹 회전 - 모든 자식 도형에 영향\\ngroup.setRotation(Math.PI / 6); // 30도 회전\\n\\n// 장면에 그룹 추가\\nengine.scene.add(group);\\n\\n// 렌더링\\nengine.render();\\n</code></pre>\\n<h2>관련 API</h2>\\n<ul>\\n<li><a href=\\"/docs/api-reference/shapes/rectangle\\">Rectangle</a> - 사각형 도형</li>\\n<li><a href=\\"/docs/api-reference/shapes/circle\\">Circle</a> - 원형 도형</li>\\n<li><a href=\\"/docs/api-reference/shapes/path\\">Path</a> - 경로 도형</li>\\n<li><a href=\\"/docs/api-reference/shapes/group\\">Group</a> - 도형 그룹</li>\\n</ul>"},"_id":"docs/api-reference/shapes/shape.md","_raw":{"sourceFilePath":"docs/api-reference/shapes/shape.md","sourceFileName":"shape.md","sourceFileDir":"docs/api-reference/shapes","contentType":"markdown","flattenedPath":"docs/api-reference/shapes/shape"},"type":"Doc","slug":"api-reference/shapes/shape","url":"/docs/api-reference/shapes/shape"}]');function a(n){let{currentSlug:e}=n,r=Object.values(c.reduce((n,e)=>{if(!e.slug)return n;let[r]=e.slug.split("/");return n[r]||(n[r]={name:r,title:r.split("-").map(n=>n.charAt(0).toUpperCase()+n.slice(1)).join(" "),items:[]}),n[r].items.push({title:e.title,slug:e.slug,description:e.description}),n},{})).sort((n,e)=>{let r={"getting-started":1,"core-concepts":2,"api-reference":3,"api-docs":4,deployment:5};return(r[n.name]||99)-(r[e.name]||99)});return(0,t.jsx)("div",{className:"w-full",children:r.map(n=>(0,t.jsxs)("div",{className:"mb-6",children:[(0,t.jsx)("h4",{className:"font-medium mb-2 text-sm text-foreground",children:n.title}),(0,t.jsx)("ul",{className:"space-y-1",children:n.items.map(n=>(0,t.jsx)("li",{children:(0,t.jsx)(i(),{href:"/docs/".concat(n.slug),className:"text-sm block py-1 px-2 rounded-md ".concat(e===n.slug?"bg-muted font-medium text-foreground":"text-muted-foreground hover:text-foreground"),children:n.title})},n.slug))})]},n.name))})}[...s,...c]},4763:(n,e,r)=>{"use strict";r.d(e,{MobileNav:()=>x});var t=r(4568),o=r(7620),i=r(5770),s=r.n(i),c=r(47),a=r(4458),d=r(5814),p=r(5680),l=r(3312),g=r(2393);let h=d.bL,u=d.l9;d.bm;let m=d.ZL,f=o.forwardRef((n,e)=>{let{className:r,...o}=n;return(0,t.jsx)(d.hJ,{className:(0,g.cn)("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",r),...o,ref:e})});f.displayName=d.hJ.displayName;let v=(0,p.F)("fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",{variants:{side:{top:"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",bottom:"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",left:"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",right:"inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm"}},defaultVariants:{side:"right"}}),b=o.forwardRef((n,e)=>{let{side:r="right",className:o,children:i,...s}=n;return(0,t.jsxs)(m,{children:[(0,t.jsx)(f,{}),(0,t.jsxs)(d.UC,{ref:e,className:(0,g.cn)(v({side:r}),o),...s,children:[i,(0,t.jsxs)(d.bm,{className:"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary",children:[(0,t.jsx)(l.A,{className:"h-4 w-4"}),(0,t.jsx)("span",{className:"sr-only",children:"Close"})]})]})]})});b.displayName=d.UC.displayName;let y=o.forwardRef((n,e)=>{let{className:r,...o}=n;return(0,t.jsx)(d.hE,{ref:e,className:(0,g.cn)("text-lg font-semibold text-foreground",r),...o})});y.displayName=d.hE.displayName,o.forwardRef((n,e)=>{let{className:r,...o}=n;return(0,t.jsx)(d.VY,{ref:e,className:(0,g.cn)("text-sm text-muted-foreground",r),...o})}).displayName=d.VY.displayName;var P=r(2e3);function x(n){let{currentSlug:e}=n,[r,i]=(0,o.useState)(!1);return(0,t.jsxs)(h,{open:r,onOpenChange:i,children:[(0,t.jsx)(u,{asChild:!0,children:(0,t.jsxs)(a.Button,{variant:"ghost",className:"mr-2 px-0 text-base hover:bg-transparent focus-visible:bg-transparent focus-visible:ring-0 focus-visible:ring-offset-0 md:hidden",children:[(0,t.jsx)(c.A,{className:"h-6 w-6"}),(0,t.jsx)("span",{className:"sr-only",children:"Toggle Menu"})]})}),(0,t.jsxs)(b,{side:"left",className:"pr-0",children:[(0,t.jsx)(y,{className:"sr-only",children:"Navigation Menu"}),(0,t.jsx)("div",{className:"px-7",children:(0,t.jsx)(s(),{href:"/",className:"flex items-center",onClick:()=>i(!1),children:(0,t.jsx)("span",{className:"font-bold",children:"Modern Vector.js"})})}),(0,t.jsx)("div",{className:"my-4 h-[calc(100vh-8rem)] pb-10 pl-6 overflow-y-auto",children:(0,t.jsx)(P.DocsNavigation,{currentSlug:e})})]})]})}},4458:(n,e,r)=>{"use strict";r.d(e,{Button:()=>d});var t=r(4568),o=r(7620),i=r(1217),s=r(5680),c=r(2393);let a=(0,s.F)("inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",{variants:{variant:{default:"bg-primary text-primary-foreground hover:bg-primary/90",destructive:"bg-destructive text-destructive-foreground hover:bg-destructive/90",outline:"border border-input hover:bg-accent hover:text-accent-foreground",secondary:"bg-secondary text-secondary-foreground hover:bg-secondary/80",ghost:"hover:bg-accent hover:text-accent-foreground",link:"text-primary underline-offset-4 hover:underline"},size:{default:"h-10 px-4 py-2",sm:"h-9 rounded-md px-3",lg:"h-11 rounded-md px-8",icon:"h-10 w-10"}},defaultVariants:{variant:"default",size:"default"}}),d=o.forwardRef((n,e)=>{let{className:r,variant:o,size:s,asChild:d=!1,...p}=n,l=d?i.DX:"button";return(0,t.jsx)(l,{className:(0,c.cn)(a({variant:o,size:s,className:r})),ref:e,...p})});d.displayName="Button"},2393:(n,e,r)=>{"use strict";r.d(e,{cn:()=>i});var t=r(9182),o=r(5402);function i(){for(var n=arguments.length,e=Array(n),r=0;r<n;r++)e[r]=arguments[r];return(0,o.QP)((0,t.$)(e))}}},n=>{var e=e=>n(n.s=e);n.O(0,[770,816,508,435,587,855,358],()=>e(3499)),_N_E=n.O()}]);